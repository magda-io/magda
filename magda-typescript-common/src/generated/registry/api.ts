/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require("request");
import http = require("http");

let defaultBasePath = "http://localhost/api/v0/registry/";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ApiError {
    "message": string;
}

/**
 * A type of aspect in the registry, unique for a tenant.
 */
export class AspectDefinition {
    /**
     * The identifier for the aspect type.
     */
    "id": string;
    /**
     * The name of the aspect.
     */
    "name": string;
    /**
     * The JSON Schema of this aspect.
     */
    "jsonSchema": any;
}

export class CountResponse {
    "count": number;
}

export class DeleteRecordsAspectArrayItemsRequest {
    "recordIds": Array<string>;
    "jsonPath": string;
    "items": Array<JsValue>;
}

export class DeleteResult {
    "deleted": boolean;
}

/**
 * The type of a registry modification event.
 */
export type EventType =
    | "CreateRecord"
    | "CreateAspectDefinition"
    | "CreateRecordAspect"
    | "PatchRecord"
    | "PatchAspectDefinition"
    | "PatchRecordAspect"
    | "DeleteRecord"
    | "DeleteAspectDefinition"
    | "DeleteRecordAspect";

/**
 * A page of events.
 */
export class EventsPage {
    /**
     * Whether there are more events available.
     */
    "hasMore": boolean;
    /**
     * A token to be used to get the next page of events.
     */
    "nextPageToken": string;
    /**
     * The events in this page.
     */
    "events": Array<RegistryEvent>;
}

export class JsObject {
    "fields": { [key: string]: JsValue };
}

export class JsValue {}

export class JsonPatch {
    "ops": Array<Operation>;
}

export class MultipleDeleteResult {
    "count": number;
}

export class Operation {}

export class PatchRecordsRequest {
    "recordIds": Array<string>;
    "jsonPath": JsonPatch;
}

export class PutRecordsAspectRequest {
    "recordIds": Array<string>;
    "data": JsObject;
}

/**
 * A record in the registry, usually including data for one or more aspects, unique for a tenant.
 */
export class Record {
    /**
     * The identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The aspects included in this record
     */
    "aspects": any;
    /**
     * A tag representing the action by the source of this record (e.g. an id for a individual crawl of a data portal).
     */
    "sourceTag": string;
    /**
     * The identifier of a tenant
     */
    "tenantId": number;
}

/**
 * A summary of a record in the registry.  Summaries specify which aspects are available, but do not include data for any aspects.
 */
export class RecordSummary {
    /**
     * The identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The list of aspect IDs for which this record has data
     */
    "aspects": Array<string>;
    /**
     * The identifier of the tenant
     */
    "tenantId": number;
}

export class RegistryEvent {
    "id": any;
    "eventTime": Date;
    "eventType": EventType;
    "userId": string;
    "data": JsObject;
    "tenantId": number;
}

export class WebHook {
    "id": string;
    "name": string;
    "active": boolean;
    "lastEvent": any;
    "url": string;
    "eventTypes": Array<EventType>;
    "isWaitingForResponse": any;
    "config": WebHookConfig;
    "enabled": boolean;
    "lastRetryTime": Date;
    "retryCount": number;
    "isRunning": any;
    "isProcessing": any;
    "ownerId": string;
    "creatorId": string;
    "editorId": string;
    "createTime": Date;
    "editTime": Date;
}

/**
 * Asynchronously acknowledges receipt of a web hook notification.
 */
export class WebHookAcknowledgement {
    /**
     * True if the web hook was received successfully and the listener is ready for further notifications.  False if the web hook was not received and the same notification should be repeated.
     */
    "succeeded": boolean;
    /**
     * The ID of the last event received by the listener.  This should be the value of the `lastEventId` property of the web hook payload that is being acknowledged.  This value is ignored if `succeeded` is false.
     */
    "lastEventIdReceived": any;
    /**
     * Should the webhook be active or inactive?
     */
    "active": any;
}

/**
 * The response to an asynchronous web hook acknowledgement.
 */
export class WebHookAcknowledgementResponse {
    /**
     * The ID of the last event successfully received by the listener.  Further notifications will start after this event.
     */
    "lastEventIdReceived": number;
}

export class WebHookConfig {
    "aspects": Array<string>;
    "optionalAspects": Array<string>;
    "includeEvents": any;
    "includeRecords": any;
    "includeAspectDefinitions": any;
    "dereference": any;
}

export interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username,
            password: this.password
        };
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {}

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (
            this.location == "header" &&
            requestOptions &&
            requestOptions.headers
        ) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] =
                "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AspectDefinitionsApiApiKeys {}

export class AspectDefinitionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AspectDefinitionsApiApiKeys, value: string) {
        this.authentications[AspectDefinitionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new aspect
     *
     * @param xMagdaTenantId 0
     * @param aspect The definition of the new aspect.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        xMagdaTenantId: number,
        aspect: AspectDefinition,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath = this.basePath + "/aspects";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling create."
            );
        }

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all aspects
     *
     * @param xMagdaTenantId 0
     * @param xMagdaSession Magda internal session id
     */
    public getAll(
        xMagdaTenantId: number,
        xMagdaSession?: string
    ): Promise<{
        response: http.IncomingMessage;
        body: Array<AspectDefinition>;
    }> {
        const localVarPath = this.basePath + "/aspects";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getAll."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<AspectDefinition>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an aspect by ID
     *
     * @param xMagdaTenantId 0
     * @param id ID of the aspect to be fetched.
     * @param xMagdaSession Magda internal session id
     */
    public getById(
        xMagdaTenantId: number,
        id: string,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getById."
            );
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify an aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param xMagdaTenantId 0
     * @param id ID of the aspect to be saved.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     */
    public patchById(
        xMagdaTenantId: number,
        id: string,
        aspectPatch: Array<Operation>,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectPatch' is not null or undefined
        if (aspectPatch === null || aspectPatch === undefined) {
            throw new Error(
                "Required parameter aspectPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspectPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify an aspect by ID
     * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
     * @param xMagdaTenantId 0
     * @param id ID of the aspect to be saved.
     * @param aspect The aspect to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        xMagdaTenantId: number,
        id: string,
        aspect: AspectDefinition,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecordAspectsApiApiKeys {}

export class RecordAspectsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordAspectsApiApiKeys, value: string) {
        this.authentications[RecordAspectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete a record aspect by ID
     * Deletes a record aspect.
     * @param recordId ID of the record for which to delete an aspect.
     * @param aspectId ID of the aspect to delete.
     * @param xMagdaSession Magda internal session id
     * @param xMagdaTenantId 0
     */
    public deleteById(
        recordId: string,
        aspectId: string,
        xMagdaSession: string,
        xMagdaTenantId: number
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of a record&#39;s aspects
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record for which to fetch aspects.
     * @param keyword Specify the keyword to search in the all aspects&#39; aspectId &amp; data fields.
     * @param aspectIdOnly When set to true, will respond only an array contains aspect id only.
     * @param start The index of the first record to retrieve.
     * @param limit The maximum number of records to receive.
     * @param xMagdaSession Magda internal session id
     */
    public getAspects(
        xMagdaTenantId: number,
        recordId: string,
        keyword?: string,
        aspectIdOnly?: boolean,
        start?: number,
        limit?: number,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Array<any> }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getAspects."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling getAspects."
            );
        }

        if (keyword !== undefined) {
            queryParameters["keyword"] = keyword;
        }

        if (aspectIdOnly !== undefined) {
            queryParameters["aspectIdOnly"] = aspectIdOnly;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<any>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the number of aspects that a record has
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record for which to fetch an aspect.
     * @param keyword Specify the keyword to search in the all aspects&#39; aspectId &amp; data fields.
     * @param xMagdaSession Magda internal session id
     */
    public getAspectsCount(
        xMagdaTenantId: number,
        recordId: string,
        keyword?: string,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: CountResponse }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/count".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getAspectsCount."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling getAspectsCount."
            );
        }

        if (keyword !== undefined) {
            queryParameters["keyword"] = keyword;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: CountResponse;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a record aspect by ID
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param xMagdaSession Magda internal session id
     */
    public getById(
        xMagdaTenantId: number,
        recordId: string,
        aspectId: string,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getById."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling getById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling getById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a record aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     * @param xMagdaTenantId 0
     */
    public patchById(
        recordId: string,
        aspectId: string,
        aspectPatch: Array<Operation>,
        xMagdaSession: string,
        xMagdaTenantId: number
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectPatch' is not null or undefined
        if (aspectPatch === null || aspectPatch === undefined) {
            throw new Error(
                "Required parameter aspectPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspectPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a record aspect by ID
     * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
     * @param recordId ID of the record for which to update an aspect.
     * @param aspectId ID of the aspect to update.
     * @param aspect The record aspect to save.
     * @param xMagdaSession Magda internal session id
     * @param xMagdaTenantId 0
     * @param merge Whether merge the supplied aspect data to existing aspect data or replace it
     */
    public putById(
        recordId: string,
        aspectId: string,
        aspect: any,
        xMagdaSession: string,
        xMagdaTenantId: number,
        merge?: boolean
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling putById."
            );
        }

        if (merge !== undefined) {
            queryParameters["merge"] = merge;
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
export enum RecordHistoryApiApiKeys {}

export class RecordHistoryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordHistoryApiApiKeys, value: string) {
        this.authentications[RecordHistoryApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get a list of all events affecting this record
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record for which to fetch history.
     * @param xMagdaSession Magda internal session id
     * @param pageToken A token that identifies the start of a page of events.  This token should not be interpreted as having any meaning, but it can be obtained from a previous page of results.
     * @param start The index of the first event to retrieve.  When possible, specify pageToken instead as it will result in better performance.  If this parameter and pageToken are both specified, this parameter is interpreted as the index after the pageToken of the first record to retrieve.
     * @param limit The maximum number of events to receive.  The response will include a token that can be passed as the pageToken parameter to a future request to continue receiving results where this query leaves off.
     * @param aspect The aspects for which to included in event history, specified as multiple occurrences of this query parameter.
     * @param dereference true to automatically dereference links to other records; false to leave them as links.  Dereferencing a link means including the record itself where the link would be.  Dereferencing only happens one level deep, regardless of the value of this parameter.
     * @param reversePageTokenOrder When pagination via pageToken, by default, records with smaller pageToken (i.e. older records) will be returned first. When this parameter is set to &#x60;true&#x60;, higher pageToken records (newer records) will be returned.
     */
    public history(
        xMagdaTenantId: number,
        recordId: string,
        xMagdaSession: string,
        pageToken?: string,
        start?: number,
        limit?: number,
        aspect?: Array<string>,
        dereference?: boolean,
        reversePageTokenOrder?: boolean
    ): Promise<{ response: http.IncomingMessage; body: EventsPage }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/history".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling history."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling history."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling history."
            );
        }

        if (pageToken !== undefined) {
            queryParameters["pageToken"] = pageToken;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (dereference !== undefined) {
            queryParameters["dereference"] = dereference;
        }

        if (reversePageTokenOrder !== undefined) {
            queryParameters["reversePageTokenOrder"] = reversePageTokenOrder;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: EventsPage;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the version of a record that existed after a given event was applied
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record to fetch.
     * @param eventId The ID of the last event to be applied to the record.  The event with this ID need not actually apply to the record, in which case that last event prior to this even that does apply will be used.
     */
    public version(
        xMagdaTenantId: number,
        recordId: string,
        eventId: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/history/{eventId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "eventId" + "}", String(eventId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling version."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling version."
            );
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error(
                "Required parameter eventId was null or undefined when calling version."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
export enum RecordsApiApiKeys {}

export class RecordsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordsApiApiKeys, value: string) {
        this.authentications[RecordsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new record
     *
     * @param xMagdaTenantId 0
     * @param record The definition of the new record.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        xMagdaTenantId: number,
        record: Record,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling create."
            );
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error(
                "Required parameter record was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: record
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Delete a record
     *
     * @param xMagdaTenantId 0
     * @param recordId ID of the record to delete.
     * @param xMagdaSession Magda internal session id
     */
    public deleteById(
        xMagdaTenantId: number,
        recordId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove items from records&#39; aspect data
     * Remove items from records&#39; aspect data
     * @param xMagdaTenantId 0
     * @param aspectId ID of the aspect to update.
     * @param requestData An json object has key &#39;recordIds&#39;, &#39;jsonPath&#39;, &#39;items&#39;
     * @param xMagdaSession Magda internal session id
     */
    public deleteRecordsAspectArrayItems(
        xMagdaTenantId: number,
        aspectId: string,
        requestData: DeleteRecordsAspectArrayItemsRequest,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Array<any> }> {
        const localVarPath =
            this.basePath +
            "/records/aspectArrayItems/{aspectId}".replace(
                "{" + "aspectId" + "}",
                String(aspectId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling deleteRecordsAspectArrayItems."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling deleteRecordsAspectArrayItems."
            );
        }

        // verify required parameter 'requestData' is not null or undefined
        if (requestData === null || requestData === undefined) {
            throw new Error(
                "Required parameter requestData was null or undefined when calling deleteRecordsAspectArrayItems."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteRecordsAspectArrayItems."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: requestData
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<any>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all records
     *
     * @param xMagdaTenantId 0
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param optionalAspect The optional aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  These aspects will be included in a record if available, but a record will be included even if it is missing these aspects.
     * @param pageToken A token that identifies the start of a page of results.  This token should not be interpreted as having any meaning, but it can be obtained from a previous page of results.
     * @param start The index of the first record to retrieve.  When possible, specify pageToken instead as it will result in better performance.  If this parameter and pageToken are both specified, this parameter is interpreted as the index after the pageToken of the first record to retrieve.
     * @param limit The maximum number of records to receive.  The response will include a token that can be passed as the pageToken parameter to a future request to continue receiving results where this query leaves off.
     * @param dereference true to automatically dereference links to other records; false to leave them as links.  Dereferencing a link means including the record itself where the link would be.  Dereferencing only happens one level deep, regardless of the value of this parameter.
     * @param aspectQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. NOTE: This is an early stage API and may change greatly in the future
     * @param aspectOrQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. Queries passing via this parameter will be grouped with OR logic. NOTE: This is an early stage API and may change greatly in the future
     * @param orderBy Specify the field to sort the result. Aspect field can be supported in a format like aspectId.path.to.field
     * @param orderByDir Specify the order by direction. Either &#x60;asc&#x60; or &#x60;desc&#x60;
     * @param orderNullFirst Specify whether nulls appear before (&#x60;true&#x60;) or after (&#x60;false&#x60;) non-null values in the sort ordering.
     * @param reversePageTokenOrder When pagination via pageToken, by default, records with smaller pageToken (i.e. older records) will be returned first. When this parameter is set to &#x60;true&#x60;, higher pageToken records (newer records) will be returned.
     * @param xMagdaSession Magda internal session id
     */
    public getAll(
        xMagdaTenantId: number,
        aspect?: Array<string>,
        optionalAspect?: Array<string>,
        pageToken?: string,
        start?: number,
        limit?: number,
        dereference?: boolean,
        aspectQuery?: Array<string>,
        aspectOrQuery?: Array<string>,
        orderBy?: string,
        orderByDir?: string,
        orderNullFirst?: boolean,
        reversePageTokenOrder?: boolean,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Array<Record> }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getAll."
            );
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (optionalAspect !== undefined) {
            queryParameters["optionalAspect"] = optionalAspect;
        }

        if (pageToken !== undefined) {
            queryParameters["pageToken"] = pageToken;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        if (dereference !== undefined) {
            queryParameters["dereference"] = dereference;
        }

        if (aspectQuery !== undefined) {
            queryParameters["aspectQuery"] = aspectQuery;
        }

        if (aspectOrQuery !== undefined) {
            queryParameters["aspectOrQuery"] = aspectOrQuery;
        }

        if (orderBy !== undefined) {
            queryParameters["orderBy"] = orderBy;
        }

        if (orderByDir !== undefined) {
            queryParameters["orderByDir"] = orderByDir;
        }

        if (orderNullFirst !== undefined) {
            queryParameters["orderNullFirst"] = orderNullFirst;
        }

        if (reversePageTokenOrder !== undefined) {
            queryParameters["reversePageTokenOrder"] = reversePageTokenOrder;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<Record>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all records as summaries
     *
     * @param xMagdaTenantId 0
     * @param pageToken A token that identifies the start of a page of results.  This token should not be interpreted as having any meaning, but it can be obtained from a previous page of results.
     * @param start The index of the first record to retrieve.  When possible, specify pageToken instead as it will result in better performance.  If this parameter and pageToken are both specified, this parameter is interpreted as the index after the pageToken of the first record to retrieve.
     * @param limit The maximum number of records to receive.  The response will include a token that can be passed as the pageToken parameter to a future request to continue receiving results where this query leaves off.
     * @param reversePageTokenOrder When pagination via pageToken, by default, records with smaller pageToken (i.e. older records) will be returned first. When this parameter is set to &#x60;true&#x60;, higher pageToken records (newer records) will be returned.
     * @param xMagdaSession Magda internal session id
     */
    public getAllSummary(
        xMagdaTenantId: number,
        pageToken?: string,
        start?: number,
        limit?: number,
        reversePageTokenOrder?: boolean,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Array<RecordSummary> }> {
        const localVarPath = this.basePath + "/records/summary";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getAllSummary."
            );
        }

        if (pageToken !== undefined) {
            queryParameters["pageToken"] = pageToken;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        if (reversePageTokenOrder !== undefined) {
            queryParameters["reversePageTokenOrder"] = reversePageTokenOrder;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<RecordSummary>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a record by ID
     * Gets a complete record, including data for all aspects.
     * @param id ID of the record to be fetched.
     * @param xMagdaTenantId 0
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param optionalAspect The optional aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  These aspects will be included in a record if available, but a record will be included even if it is missing these aspects.
     * @param dereference true to automatically dereference links to other records; false to leave them as links.  Dereferencing a link means including the record itself where the link would be.  Dereferencing only happens one level deep, regardless of the value of this parameter.
     * @param xMagdaSession Magda internal session id
     */
    public getById(
        id: string,
        xMagdaTenantId: number,
        aspect?: Array<string>,
        optionalAspect?: Array<string>,
        dereference?: boolean,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getById."
            );
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (optionalAspect !== undefined) {
            queryParameters["optionalAspect"] = optionalAspect;
        }

        if (dereference !== undefined) {
            queryParameters["dereference"] = dereference;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Get a record in full by ID
     * Get a record with all attached aspects data by the record ID.
     * @param id ID of the record to be fetched.
     * @param xMagdaTenantId 0
     * @param xMagdaSession Magda internal session id
     */
    public getByIdInFull(
        id: string,
        xMagdaTenantId: number,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/inFull/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getByIdInFull."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getByIdInFull."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Get a summary record by ID
     * Gets a summary record, including all the aspect ids for which this record has data.
     * @param id ID of the record to be fetched.
     * @param xMagdaTenantId 0
     * @param xMagdaSession Magda internal session id
     */
    public getByIdSummary(
        id: string,
        xMagdaTenantId: number,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: RecordSummary }> {
        const localVarPath =
            this.basePath +
            "/records/summary/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getByIdSummary."
            );
        }

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getByIdSummary."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: RecordSummary;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the count of records matching the parameters. If no parameters are specified, the count will be approximate for performance reasons.
     *
     * @param xMagdaTenantId 0
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param aspectQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. NOTE: This is an early stage API and may change greatly in the future
     * @param aspectOrQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. Queries passing via this parameter will be grouped with OR logic.
     * @param xMagdaSession Magda internal session id
     */
    public getCount(
        xMagdaTenantId: number,
        aspect?: Array<string>,
        aspectQuery?: Array<string>,
        aspectOrQuery?: Array<string>,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: CountResponse }> {
        const localVarPath = this.basePath + "/records/count";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getCount."
            );
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (aspectQuery !== undefined) {
            queryParameters["aspectQuery"] = aspectQuery;
        }

        if (aspectOrQuery !== undefined) {
            queryParameters["aspectOrQuery"] = aspectOrQuery;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: CountResponse;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list tokens for paging through the records
     *
     * @param xMagdaTenantId 0
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param limit The size of each page to get tokens for.
     * @param xMagdaSession Magda internal session id
     */
    public getPageTokens(
        xMagdaTenantId: number,
        aspect?: Array<string>,
        limit?: number,
        xMagdaSession?: string
    ): Promise<{ response: http.IncomingMessage; body: Array<string> }> {
        const localVarPath = this.basePath + "/records/pagetokens";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling getPageTokens."
            );
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<string>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify a record by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param xMagdaTenantId 0
     * @param id ID of the record to be pacthed.
     * @param recordPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     */
    public patchById(
        xMagdaTenantId: number,
        id: string,
        recordPatch: Array<Operation>,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'recordPatch' is not null or undefined
        if (recordPatch === null || recordPatch === undefined) {
            throw new Error(
                "Required parameter recordPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: recordPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a list of records by applying the same JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param xMagdaTenantId 0
     * @param requestData An json object has key &#39;recordIds&#39; &amp; &#39;jsonPath&#39;
     * @param xMagdaSession Magda internal session id
     */
    public patchRecords(
        xMagdaTenantId: number,
        requestData: PatchRecordsRequest,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Array<any> }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling patchRecords."
            );
        }

        // verify required parameter 'requestData' is not null or undefined
        if (requestData === null || requestData === undefined) {
            throw new Error(
                "Required parameter requestData was null or undefined when calling patchRecords."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchRecords."
            );
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: requestData
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<any>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify a record by ID
     * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
     * @param xMagdaTenantId 0
     * @param id ID of the record to be fetched.
     * @param record The record to save.
     * @param xMagdaSession Magda internal session id
     * @param merge Whether merge the supplied aspect data to existing aspect data or replace it
     */
    public putById(
        xMagdaTenantId: number,
        id: string,
        record: Record,
        xMagdaSession: string,
        merge?: boolean
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error(
                "Required parameter record was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        if (merge !== undefined) {
            queryParameters["merge"] = merge;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: record
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a list of records&#39;s aspect with same new data
     * Modify a list of records&#39;s aspect with same new data
     * @param xMagdaTenantId 0
     * @param aspectId ID of the aspect to update.
     * @param requestData An json object has key &#39;recordIds&#39; &amp; &#39;data&#39;
     * @param xMagdaSession Magda internal session id
     * @param merge Whether merge the supplied aspect data to existing aspect data or replace it
     */
    public putRecordsAspect(
        xMagdaTenantId: number,
        aspectId: string,
        requestData: PutRecordsAspectRequest,
        xMagdaSession: string,
        merge?: boolean
    ): Promise<{ response: http.IncomingMessage; body: Array<any> }> {
        const localVarPath =
            this.basePath +
            "/records/aspects/{aspectId}".replace(
                "{" + "aspectId" + "}",
                String(aspectId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling putRecordsAspect."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling putRecordsAspect."
            );
        }

        // verify required parameter 'requestData' is not null or undefined
        if (requestData === null || requestData === undefined) {
            throw new Error(
                "Required parameter requestData was null or undefined when calling putRecordsAspect."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putRecordsAspect."
            );
        }

        if (merge !== undefined) {
            queryParameters["merge"] = merge;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: requestData
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<any>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Trim by source tag
     * Trims records with the provided source that DON&#39;T have the supplied source tag
     * @param xMagdaTenantId 0
     * @param sourceTagToPreserve Source tag of the records to PRESERVE.
     * @param sourceId Source id of the records to delete.
     * @param xMagdaSession Magda internal session id
     */
    public trimBySourceTag(
        xMagdaTenantId: number,
        sourceTagToPreserve: string,
        sourceId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: MultipleDeleteResult }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaTenantId' is not null or undefined
        if (xMagdaTenantId === null || xMagdaTenantId === undefined) {
            throw new Error(
                "Required parameter xMagdaTenantId was null or undefined when calling trimBySourceTag."
            );
        }

        // verify required parameter 'sourceTagToPreserve' is not null or undefined
        if (sourceTagToPreserve === null || sourceTagToPreserve === undefined) {
            throw new Error(
                "Required parameter sourceTagToPreserve was null or undefined when calling trimBySourceTag."
            );
        }

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                "Required parameter sourceId was null or undefined when calling trimBySourceTag."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling trimBySourceTag."
            );
        }

        if (sourceTagToPreserve !== undefined) {
            queryParameters["sourceTagToPreserve"] = sourceTagToPreserve;
        }

        if (sourceId !== undefined) {
            queryParameters["sourceId"] = sourceId;
        }

        headerParams["X-Magda-Tenant-Id"] = xMagdaTenantId;

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: MultipleDeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebHooksApiApiKeys {}

export class WebHooksApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebHooksApiApiKeys, value: string) {
        this.authentications[WebHooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Acknowledge a previously-deferred web hook
     * Acknowledges a previously-deferred web hook with a given ID.  Acknowledging a previously-POSTed web hook will cause the next, if any, to be sent.
     * @param id ID of the web hook to be acknowledged.
     * @param acknowledgement The details of the acknowledgement.
     * @param xMagdaSession Magda internal session id
     */
    public ack(
        id: string,
        acknowledgement: WebHookAcknowledgement,
        xMagdaSession: string
    ): Promise<{
        response: http.IncomingMessage;
        body: WebHookAcknowledgementResponse;
    }> {
        const localVarPath =
            this.basePath +
            "/hooks/{id}/ack".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling ack."
            );
        }

        // verify required parameter 'acknowledgement' is not null or undefined
        if (acknowledgement === null || acknowledgement === undefined) {
            throw new Error(
                "Required parameter acknowledgement was null or undefined when calling ack."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling ack."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: acknowledgement
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: WebHookAcknowledgementResponse;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new web hook
     *
     * @param hook The definition of the new web hook.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        hook: WebHook,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath = this.basePath + "/hooks";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'hook' is not null or undefined
        if (hook === null || hook === undefined) {
            throw new Error(
                "Required parameter hook was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: hook
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Delete a web hook
     *
     * @param hookId ID of the web hook to delete.
     * @param xMagdaSession Magda internal session id
     */
    public deleteById(
        hookId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/hooks/{hookId}".replace("{" + "hookId" + "}", String(hookId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error(
                "Required parameter hookId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all web hooks
     *
     * @param xMagdaSession Magda internal session id
     */
    public getAll(
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Array<WebHook> }> {
        const localVarPath = this.basePath + "/hooks";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling getAll."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<WebHook>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a web hook by ID
     *
     * @param id ID of the web hook to be fetched.
     * @param xMagdaSession Magda internal session id
     */
    public getById(
        id: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath =
            this.basePath + "/hooks/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling getById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a web hook by ID
     * Modifies the web hook with a given ID.  If a web hook with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param hook The web hook to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        id: string,
        hook: WebHook,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath =
            this.basePath + "/hooks/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'hook' is not null or undefined
        if (hook === null || hook === undefined) {
            throw new Error(
                "Required parameter hook was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: hook
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
