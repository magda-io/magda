{
  "version": 3,
  "sources": ["../../../src/dagre-wrapper/mermaid-graphlib.js", "../../../src/dagre-wrapper/clusters.js", "../../../src/dagre-wrapper/index.js", "../../../src/diagrams/class/classRenderer-v2.ts", "../../../src/diagrams/class/classDiagram-v2.ts"],
  "sourcesContent": ["/** Decorates with functions required by mermaids dagre-wrapper. */\nimport { log } from '../logger.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\n\nexport let clusterDb = {};\nlet descendants = {};\nlet parents = {};\n\nexport const clear = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\n\nconst isDescendant = (id, ancestorId) => {\n  // if (id === ancestorId) return true;\n\n  log.trace('In isDescendant', ancestorId, ' ', id, ' = ', descendants[ancestorId].includes(id));\n  if (descendants[ancestorId].includes(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst edgeInCluster = (edge, clusterId) => {\n  log.info('Descendants of ', clusterId, ' is ', descendants[clusterId]);\n  log.info('Edge is ', edge);\n  // Edges to/from the cluster is not in the cluster, they are in the parent\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n\n  if (!descendants[clusterId]) {\n    log.debug('Tilt, ', clusterId, ',not in descendants');\n    return false;\n  }\n  return (\n    descendants[clusterId].includes(edge.v) ||\n    isDescendant(edge.v, clusterId) ||\n    isDescendant(edge.w, clusterId) ||\n    descendants[clusterId].includes(edge.w)\n  );\n};\n\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    'Copying children of ',\n    clusterId,\n    'root',\n    rootId,\n    'data',\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n\n  // Include cluster node if it is not the root\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n\n  log.warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);\n\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn('Setting parent', node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug('Setting parent', node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);\n        log.debug(\n          'Not Setting parent for node=',\n          node,\n          'cluster!==rootId',\n          clusterId !== rootId,\n          'node!==clusterId',\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug('Copying Edges', edges);\n      edges.forEach((edge) => {\n        log.info('Edge', edge);\n        const data = graph.edge(edge.v, edge.w, edge.name);\n        log.info('Edge data', data, rootId);\n        try {\n          // Do not copy edges in and out of the root cluster, they belong to the parent graph\n          if (edgeInCluster(edge, rootId)) {\n            log.info('Copying as ', edge.v, edge.w, data, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data, edge.name);\n            log.info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              'Skipping copy of edge ',\n              edge.v,\n              '-->',\n              edge.w,\n              ' rootId: ',\n              rootId,\n              ' clusterId:',\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug('Removing node', node);\n    graph.removeNode(node);\n  });\n};\nexport const extractDescendants = (id, graph) => {\n  // log.debug('Extracting ', id);\n  const children = graph.children(id);\n  let res = [...children];\n\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n\n  return res;\n};\n\n/**\n * Validates the graph, checking that all parent child relation points to existing nodes and that\n * edges between nodes also ia correct. When not correct the function logs the discrepancies.\n *\n * @param graph\n */\nexport const validate = (graph) => {\n  const edges = graph.edges();\n  log.trace('Edges: ', edges);\n  for (const edge of edges) {\n    if (graph.children(edge.v).length > 0) {\n      log.trace('The node ', edge.v, ' is part of and edge even though it has children');\n      return false;\n    }\n    if (graph.children(edge.w).length > 0) {\n      log.trace('The node ', edge.w, ' is part of and edge even though it has children');\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Finds a child that is not a cluster. When faking an edge between a node and a cluster.\n *\n * @param id\n * @param {any} graph\n */\nexport const findNonClusterChild = (id, graph) => {\n  // const node = graph.node(id);\n  log.trace('Searching', id);\n  // const children = graph.children(id).reverse();\n  const children = graph.children(id); //.reverse();\n  log.trace('Searching children of id ', id, children);\n  if (children.length < 1) {\n    log.trace('This is a valid node', id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace('Found replacement for', id, ' => ', _id);\n      return _id;\n    }\n  }\n};\n\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  // If the cluster has no external connections\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n\n  // Return the replacement node\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\n\nexport const adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug('Opting out, no graph ');\n    return;\n  } else {\n    log.debug('Opting in, graph ');\n  }\n  // Go through the nodes and for each cluster found, save a replacement node, this can be used when\n  // faking a link to a cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        'Cluster identified',\n        id,\n        ' Replacement id in edges: ',\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n\n  // Check incoming and outgoing edges for each cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug('Cluster identified', id, descendants);\n      edges.forEach((edge) => {\n        // log.debug('Edge, descendants: ', edge, descendants[id]);\n\n        // Check if any edge leaves the cluster (not the actual cluster, that's a link from the box)\n        if (edge.v !== id && edge.w !== id) {\n          // Any edge where either the one of the nodes is descending to the cluster but not the other\n          // if (descendants[id].indexOf(edge.v) < 0 && descendants[id].indexOf(edge.w) < 0) {\n\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n\n          // d1 xor d2 - if either d1 is true and d2 is false or the other way around\n          if (d1 ^ d2) {\n            log.warn('Edge: ', edge, ' leaves cluster ', id);\n            log.warn('Descendants of XXX ', id, ': ', descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug('Not a cluster ', id, descendants);\n    }\n  });\n\n  for (let id of Object.keys(clusterDb)) {\n    const nonClusterChild = clusterDb[id].id;\n    const parent = graph.parent(nonClusterChild);\n\n    // Change replacement node of id to parent of current replacement node if valid\n    if (parent !== id && clusterDb[parent] && !clusterDb[parent].externalConnections) {\n      clusterDb[id].id = parent;\n    }\n  }\n\n  // For clusters with incoming and/or outgoing edges translate those edges to a real node\n  // in the cluster in order to fake the edge\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));\n\n    let v = e.v;\n    let w = e.w;\n    // Check if link is either from or to a cluster\n    log.warn(\n      'Fix XXX',\n      clusterDb,\n      'ids:',\n      e.v,\n      e.w,\n      'Translating: ',\n      clusterDb[e.v],\n      ' --- ',\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      // cspell:ignore trixing\n      log.warn('Fixing and trixing link to self - removing XXX', e.v, e.w, e.name);\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + '---' + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: '',\n        labelText: edge.label,\n        padding: 0,\n        shape: 'labelRect',\n        style: '',\n      });\n      const edge1 = structuredClone(edge);\n      const edge2 = structuredClone(edge);\n      edge1.label = '';\n      edge1.arrowTypeEnd = 'none';\n      edge2.label = '';\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n\n      graph.setEdge(v, specialId, edge1, e.name + '-cyclic-special');\n      graph.setEdge(specialId, w, edge2, e.name + '-cyclic-special');\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        const parent = graph.parent(v);\n        clusterDb[parent].externalConnections = true;\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        const parent = graph.parent(w);\n        clusterDb[parent].externalConnections = true;\n        edge.toCluster = e.w;\n      }\n      log.warn('Fix Replacing with XXX', v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn('Adjusted Graph', graphlibJson.write(graph));\n  extractor(graph, 0);\n\n  log.trace(clusterDb);\n\n  // Remove references to extracted cluster\n  // graph.edges().forEach(edge => {\n  //   if (isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId)) {\n  //     graph.removeEdge(edge);\n  //   }\n  // });\n};\n\nexport const extractor = (graph, depth) => {\n  log.warn('extractor - ', depth, graphlibJson.write(graph), graph.children('D'));\n  if (depth > 10) {\n    log.error('Bailing out');\n    return;\n  }\n  // For clusters without incoming and/or outgoing edges, create a new cluster-node\n  // containing the nodes and edges in the custer in a new graph\n  // for (let i = 0;)\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n\n  if (!hasChildren) {\n    log.debug('Done, no node has children', graph.nodes());\n    return;\n  }\n  // const clusters = Object.keys(clusterDb);\n  // clusters.forEach(clusterId => {\n  log.debug('Nodes = ', nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      'Extracting node',\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children('D'),\n      ' Depth ',\n      depth\n    );\n    // Note that the node might have been removed after the Object.keys call so better check\n    // that it still is in the game\n    if (!clusterDb[node]) {\n      // Skip if the node is not a cluster\n      log.debug('Not a cluster', node, depth);\n      // break;\n    } else if (\n      !clusterDb[node].externalConnections &&\n      // !graph.parent(node) &&\n      graph.children(node) &&\n      graph.children(node).length > 0\n    ) {\n      log.warn(\n        'Cluster without external connections, without a parent and with children',\n        node,\n        depth\n      );\n\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';\n      if (clusterDb[node]?.clusterData?.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn('Fixing dir', clusterDb[node].clusterData.dir, dir);\n      }\n\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true,\n      })\n        .setGraph({\n          rankdir: dir, // Todo: set proper spacing\n          nodesep: 50,\n          ranksep: 50,\n          marginx: 8,\n          marginy: 8,\n        })\n        .setDefaultEdgeLabel(function () {\n          return {};\n        });\n\n      log.warn('Old graph before copy', graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph,\n      });\n      log.warn('New graph after copy node: (', node, ')', graphlibJson.write(clusterGraph));\n      log.debug('Old graph after copy', graphlibJson.write(graph));\n    } else {\n      log.warn(\n        'Cluster ** ',\n        node,\n        ' **not meeting the criteria !externalConnections:',\n        !clusterDb[node].externalConnections,\n        ' no parent: ',\n        !graph.parent(node),\n        ' children ',\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children('D'),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n\n  nodes = graph.nodes();\n  log.warn('New list of nodes', nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(' Now next level', node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\n\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n\n  return result;\n};\n\nexport const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\n", "import intersectRect from './intersect/intersect-rect.js';\nimport { log } from '../logger.js';\nimport createLabel from './createLabel.js';\nimport { createText } from '../rendering-util/createText.js';\nimport { select } from 'd3';\nimport { getConfig } from '../diagram-api/diagramAPI.js';\nimport { evaluate } from '../diagrams/common/common.js';\nimport { getSubGraphTitleMargins } from '../utils/subGraphTitleMargins.js';\n\nconst rect = (parent, node) => {\n  log.info('Creating subgraph rect for ', node.id, node);\n  const siteConfig = getConfig();\n\n  // Add outer g element\n  const shapeSvg = parent\n    .insert('g')\n    .attr('class', 'cluster' + (node.class ? ' ' + node.class : ''))\n    .attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const useHtmlLabels = evaluate(siteConfig.flowchart.htmlLabels);\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n\n  // const text = label\n  //   .node()\n  //   .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n  const text =\n    node.labelType === 'markdown'\n      ? createText(label, node.labelText, { style: node.labelStyle, useHtmlLabels }, siteConfig)\n      : label.node().appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n\n  if (evaluate(siteConfig.flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  log.trace('Data ', node, JSON.stringify(node));\n  // center the rect around its coordinate\n  rect\n    .attr('style', node.style)\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - width / 2)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width)\n    .attr('height', node.height + padding);\n\n  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);\n  if (useHtmlLabels) {\n    label.attr(\n      'transform',\n      // This puts the label on top of the box instead of inside it\n      `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`\n    );\n  } else {\n    label.attr(\n      'transform',\n      // This puts the label on top of the box instead of inside it\n      `translate(${node.x}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`\n    );\n  }\n  // Center the label\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\n/**\n * Non visible cluster where the note is group with its\n *\n * @param {any} parent\n * @param {any} node\n * @returns {any} ShapeSvg\n */\nconst noteGroup = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding)\n    .attr('fill', 'none');\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  const siteConfig = getConfig();\n\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n  const innerRect = shapeSvg.append('rect');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n  if (evaluate(siteConfig.flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'outer')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding);\n  innerRect\n    .attr('class', 'inner')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding - bbox.height - 3);\n\n  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);\n  // Center the label\n  label.attr(\n    'transform',\n    `translate(${node.x - bbox.width / 2}, ${\n      node.y -\n      node.height / 2 -\n      node.padding / 3 +\n      (evaluate(siteConfig.flowchart.htmlLabels) ? 5 : 3) +\n      subGraphTitleTopMargin\n    })`\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst divider = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'divider')\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding);\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\n\nlet clusterElems = {};\n\nexport const insertCluster = (elem, node) => {\n  log.trace('Inserting cluster');\n  const shape = node.shape || 'rect';\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nexport const getClusterTitleWidth = (elem, node) => {\n  const label = createLabel(node.labelText, node.labelStyle, undefined, true);\n  elem.node().appendChild(label);\n  const width = label.getBBox().width;\n  elem.node().removeChild(label);\n  return width;\n};\n\nexport const clear = () => {\n  clusterElems = {};\n};\n\nexport const positionCluster = (node) => {\n  log.info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');\n  const el = clusterElems[node.id];\n\n  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');\n};\n", "import { layout as dagreLayout } from 'dagre-d3-es/src/dagre/index.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport insertMarkers from './markers.js';\nimport { updateNodeBounds } from './shapes/util.js';\nimport {\n  clear as clearGraphlib,\n  clusterDb,\n  adjustClustersAndEdges,\n  findNonClusterChild,\n  sortNodesByHierarchy,\n} from './mermaid-graphlib.js';\nimport { insertNode, positionNode, clear as clearNodes, setNodeElem } from './nodes.js';\nimport { insertCluster, clear as clearClusters } from './clusters.js';\nimport { insertEdgeLabel, positionEdgeLabel, insertEdge, clear as clearEdges } from './edges.js';\nimport { log } from '../logger.js';\nimport { getSubGraphTitleMargins } from '../utils/subGraphTitleMargins.js';\nimport { getConfig } from '../diagram-api/diagramAPI.js';\n\nconst recursiveRender = async (_elem, graph, diagramType, id, parentCluster, siteConfig) => {\n  log.info('Graph in recursive render: XXX', graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace('Dir in recursive render - dir:', dir);\n\n  const elem = _elem.insert('g').attr('class', 'root');\n  if (!graph.nodes()) {\n    log.info('No nodes found for', graph);\n  } else {\n    log.info('Recursive render XXX', graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace('Recursive edges', graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert('g').attr('class', 'clusters');\n  const edgePaths = elem.insert('g').attr('class', 'edgePaths');\n  const edgeLabels = elem.insert('g').attr('class', 'edgeLabels');\n  const nodes = elem.insert('g').attr('class', 'nodes');\n\n  // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated\n  // to the abstract node and is later used by dagre for the layout\n  await Promise.all(\n    graph.nodes().map(async function (v) {\n      const node = graph.node(v);\n      if (parentCluster !== undefined) {\n        const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n        // data.clusterPositioning = true;\n        log.info('Setting data for cluster XXX (', v, ') ', data, parentCluster);\n        graph.setNode(parentCluster.id, data);\n        if (!graph.parent(v)) {\n          log.trace('Setting parent', v, parentCluster.id);\n          graph.setParent(v, parentCluster.id, data);\n        }\n      }\n      log.info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));\n      if (node?.clusterNode) {\n        // const children = graph.children(v);\n        log.info('Cluster identified', v, node.width, graph.node(v));\n        // `node.graph.setGraph` applies the graph configurations such as nodeSpacing to subgraphs as without this the default values would be used\n        // We override only the `ranksep` and `nodesep` configurations to allow for setting subgraph spacing while avoiding overriding other properties\n        const { ranksep, nodesep } = graph.graph();\n        node.graph.setGraph({\n          ...node.graph.graph(),\n          ranksep,\n          nodesep,\n        });\n        const o = await recursiveRender(\n          nodes,\n          node.graph,\n          diagramType,\n          id,\n          graph.node(v),\n          siteConfig\n        );\n        const newEl = o.elem;\n        updateNodeBounds(node, newEl);\n        node.diff = o.diff || 0;\n        log.info('Node bounds (abc123)', v, node, node.width, node.x, node.y);\n        setNodeElem(newEl, node);\n\n        log.warn('Recursive render complete ', newEl, node);\n      } else {\n        if (graph.children(v).length > 0) {\n          // This is a cluster but not to be rendered recursively\n          // Render as before\n          log.info('Cluster - the non recursive path XXX', v, node.id, node, graph);\n          log.info(findNonClusterChild(node.id, graph));\n          clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n          // insertCluster(clusters, graph.node(v));\n        } else {\n          log.info('Node - the non recursive path', v, node.id, node);\n          await insertNode(nodes, graph.node(v), dir);\n        }\n      }\n    })\n  );\n\n  // Insert labels, this will insert them into the dom so that the width can be calculated\n  // Also figure out which edges point to/from clusters and adjust them accordingly\n  // Edges from/to clusters really points to the first child in the cluster.\n  // TODO: pick optimal child in the cluster to us as link anchor\n  graph.edges().forEach(async function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e)));\n\n    // Check if link is either from or to a cluster\n    log.info('Fix', clusterDb, 'ids:', e.v, e.w, 'Translating: ', clusterDb[e.v], clusterDb[e.w]);\n    await insertEdgeLabel(edgeLabels, edge);\n  });\n\n  graph.edges().forEach(function (e) {\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n  });\n  log.info('Graph before layout:', JSON.stringify(graphlibJson.write(graph)));\n  log.info('#############################################');\n  log.info('###                Layout                 ###');\n  log.info('#############################################');\n  log.info(graph);\n  dagreLayout(graph);\n  log.info('Graph after layout:', JSON.stringify(graphlibJson.write(graph)));\n  // Move the nodes to the correct place\n  let diff = 0;\n  const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));\n    log.info(\n      'Position ' + v + ': (' + node.x,\n      ',' + node.y,\n      ') width: ',\n      node.width,\n      ' height: ',\n      node.height\n    );\n    if (node?.clusterNode) {\n      // clusterDb[node.id].node = node;\n      node.y += subGraphTitleTotalMargin;\n      positionNode(node);\n    } else {\n      // Non cluster node\n      if (graph.children(v).length > 0) {\n        // A cluster in the non-recursive way\n        // positionCluster(node);\n        node.height += subGraphTitleTotalMargin;\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        node.y += subGraphTitleTotalMargin / 2;\n        positionNode(node);\n      }\n    }\n  });\n\n  // Move the edge labels to the correct place after layout\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);\n\n    edge.points.forEach((point) => (point.y += subGraphTitleTotalMargin / 2));\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramType, graph, id);\n    positionEdgeLabel(edge, paths);\n  });\n\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === 'group') {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\n\nexport const render = async (elem, graph, markers, diagramType, id) => {\n  insertMarkers(elem, markers, diagramType, id);\n  clearNodes();\n  clearEdges();\n  clearClusters();\n  clearGraphlib();\n\n  log.warn('Graph at first:', JSON.stringify(graphlibJson.write(graph)));\n  adjustClustersAndEdges(graph);\n  log.warn('Graph after:', JSON.stringify(graphlibJson.write(graph)));\n  // log.warn('Graph ever  after:', graphlibJson.write(graph.node('A').graph));\n  const siteConfig = getConfig();\n  await recursiveRender(elem, graph, diagramType, id, undefined, siteConfig);\n};\n\n// const shapeDefinitions = {};\n// export const addShape = ({ shapeType: fun }) => {\n//   shapeDefinitions[shapeType] = fun;\n// };\n\n// const arrowDefinitions = {};\n// export const addArrow = ({ arrowType: fun }) => {\n//   arrowDefinitions[arrowType] = fun;\n// };\n", "// @ts-nocheck - don't check until handle it\nimport { select, curveLinear } from 'd3';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\nimport { log } from '../../logger.js';\nimport { getConfig } from '../../diagram-api/diagramAPI.js';\nimport { render } from '../../dagre-wrapper/index.js';\nimport utils, { getEdgeId } from '../../utils.js';\nimport { interpolateToCurve, getStylesFromArray } from '../../utils.js';\nimport { setupGraphViewbox } from '../../setupGraphViewbox.js';\nimport common from '../common/common.js';\nimport type { ClassRelation, ClassNote, ClassMap, NamespaceMap } from './classTypes.js';\nimport type { EdgeData } from '../../types.js';\n\nconst sanitizeText = (txt: string) => common.sanitizeText(txt, getConfig());\n\nlet conf = {\n  dividerMargin: 10,\n  padding: 5,\n  textHeight: 10,\n  curve: undefined,\n};\n\ninterface RectParameters {\n  id: string;\n  shape: 'rect';\n  labelStyle: string;\n  domId: string;\n  labelText: string;\n  padding: number | undefined;\n  style?: string;\n}\n\n/**\n * Function that adds the vertices found during parsing to the graph to be rendered.\n *\n * @param namespaces - Object containing the vertices.\n * @param g - The graph that is to be drawn.\n * @param _id - id of the graph\n * @param diagObj - The diagram object\n */\nexport const addNamespaces = function (\n  namespaces: NamespaceMap,\n  g: graphlib.Graph,\n  _id: string,\n  diagObj: any\n) {\n  log.info('keys:', [...namespaces.keys()]);\n  log.info(namespaces);\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  namespaces.forEach(function (vertex) {\n    // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]\n    const shape = 'rect';\n\n    const node: RectParameters = {\n      shape: shape,\n      id: vertex.id,\n      domId: vertex.domId,\n      labelText: sanitizeText(vertex.id),\n      labelStyle: '',\n      style: 'fill: none; stroke: black',\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      padding: getConfig().flowchart?.padding ?? getConfig().class?.padding,\n    };\n\n    g.setNode(vertex.id, node);\n    addClasses(vertex.classes, g, _id, diagObj, vertex.id);\n\n    log.info('setNode', node);\n  });\n};\n\n/**\n * Function that adds the vertices found during parsing to the graph to be rendered.\n *\n * @param classes - Object containing the vertices.\n * @param g - The graph that is to be drawn.\n * @param _id - id of the graph\n * @param diagObj - The diagram object\n * @param parent - id of the parent namespace, if it exists\n */\nexport const addClasses = function (\n  classes: ClassMap,\n  g: graphlib.Graph,\n  _id: string,\n  diagObj: any,\n  parent?: string\n) {\n  log.info('keys:', [...classes.keys()]);\n  log.info(classes);\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  [...classes.values()]\n    .filter((vertex) => vertex.parent === parent)\n    .forEach(function (vertex) {\n      /**\n       * Variable for storing the classes for the vertex\n       */\n      const cssClassStr = vertex.cssClasses.join(' ');\n\n      const styles = getStylesFromArray(vertex.styles);\n\n      // Use vertex id as text in the box if no text is provided by the graph definition\n      const vertexText = vertex.label ?? vertex.id;\n      const radius = 0;\n      const shape = 'class_box';\n\n      // Add the node\n      const node = {\n        labelStyle: styles.labelStyle,\n        shape: shape,\n        labelText: sanitizeText(vertexText),\n        classData: vertex,\n        rx: radius,\n        ry: radius,\n        class: cssClassStr,\n        style: styles.style,\n        id: vertex.id,\n        domId: vertex.domId,\n        tooltip: diagObj.db.getTooltip(vertex.id, parent) || '',\n        haveCallback: vertex.haveCallback,\n        link: vertex.link,\n        width: vertex.type === 'group' ? 500 : undefined,\n        type: vertex.type,\n        // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n        padding: getConfig().flowchart?.padding ?? getConfig().class?.padding,\n      };\n      g.setNode(vertex.id, node);\n\n      if (parent) {\n        g.setParent(vertex.id, parent);\n      }\n\n      log.info('setNode', node);\n    });\n};\n\n/**\n * Function that adds the additional vertices (notes) found during parsing to the graph to be rendered.\n *\n * @param notes - Object containing the additional vertices (notes).\n * @param g - The graph that is to be drawn.\n * @param startEdgeId - starting index for note edge\n * @param classes - Classes\n */\nexport const addNotes = function (\n  notes: ClassNote[],\n  g: graphlib.Graph,\n  startEdgeId: number,\n  classes: ClassMap\n) {\n  log.info(notes);\n\n  notes.forEach(function (note, i) {\n    const vertex = note;\n\n    const cssNoteStr = '';\n\n    const styles = { labelStyle: '', style: '' };\n\n    const vertexText = vertex.text;\n\n    const radius = 0;\n    const shape = 'note';\n    const node = {\n      labelStyle: styles.labelStyle,\n      shape: shape,\n      labelText: sanitizeText(vertexText),\n      noteData: vertex,\n      rx: radius,\n      ry: radius,\n      class: cssNoteStr,\n      style: styles.style,\n      id: vertex.id,\n      domId: vertex.id,\n      tooltip: '',\n      type: 'note',\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      padding: getConfig().flowchart?.padding ?? getConfig().class?.padding,\n    };\n    g.setNode(vertex.id, node);\n    log.info('setNode', node);\n\n    if (!vertex.class || !classes.has(vertex.class)) {\n      return;\n    }\n    const edgeId = startEdgeId + i;\n\n    const edgeData: EdgeData = {\n      id: `edgeNote${edgeId}`,\n      //Set relationship style and line type\n      classes: 'relation',\n      pattern: 'dotted',\n      // Set link type for rendering\n      arrowhead: 'none',\n      //Set edge extra labels\n      startLabelRight: '',\n      endLabelLeft: '',\n      //Set relation arrow types\n      arrowTypeStart: 'none',\n      arrowTypeEnd: 'none',\n      style: 'fill:none',\n      labelStyle: '',\n      curve: interpolateToCurve(conf.curve, curveLinear),\n    };\n\n    // Add the edge to the graph\n    g.setEdge(vertex.id, vertex.class, edgeData, edgeId);\n  });\n};\n\n/**\n * Add edges to graph based on parsed graph definition\n *\n * @param relations -\n * @param g - The graph object\n */\nexport const addRelations = function (relations: ClassRelation[], g: graphlib.Graph) {\n  const conf = getConfig().flowchart;\n  let cnt = 0;\n\n  relations.forEach(function (edge) {\n    cnt++;\n    const edgeData: EdgeData = {\n      //Set relationship style and line type\n      classes: 'relation',\n      pattern: edge.relation.lineType == 1 ? 'dashed' : 'solid',\n      id: getEdgeId(edge.id1, edge.id2, {\n        prefix: 'id',\n        counter: cnt,\n      }),\n      // Set link type for rendering\n      arrowhead: edge.type === 'arrow_open' ? 'none' : 'normal',\n      //Set edge extra labels\n      startLabelRight: edge.relationTitle1 === 'none' ? '' : edge.relationTitle1,\n      endLabelLeft: edge.relationTitle2 === 'none' ? '' : edge.relationTitle2,\n      //Set relation arrow types\n      arrowTypeStart: getArrowMarker(edge.relation.type1),\n      arrowTypeEnd: getArrowMarker(edge.relation.type2),\n      style: 'fill:none',\n      labelStyle: '',\n      curve: interpolateToCurve(conf?.curve, curveLinear),\n    };\n\n    log.info(edgeData, edge);\n\n    if (edge.style !== undefined) {\n      const styles = getStylesFromArray(edge.style);\n      edgeData.style = styles.style;\n      edgeData.labelStyle = styles.labelStyle;\n    }\n\n    edge.text = edge.title;\n    if (edge.text === undefined) {\n      if (edge.style !== undefined) {\n        edgeData.arrowheadStyle = 'fill: #333';\n      }\n    } else {\n      edgeData.arrowheadStyle = 'fill: #333';\n      edgeData.labelpos = 'c';\n\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      if (getConfig().flowchart?.htmlLabels ?? getConfig().htmlLabels) {\n        edgeData.labelType = 'html';\n        edgeData.label = '<span class=\"edgeLabel\">' + edge.text + '</span>';\n      } else {\n        edgeData.labelType = 'text';\n        edgeData.label = edge.text.replace(common.lineBreakRegex, '\\n');\n\n        if (edge.style === undefined) {\n          edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none';\n        }\n\n        edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');\n      }\n    }\n    // Add the edge to the graph\n    g.setEdge(edge.id1, edge.id2, edgeData, cnt);\n  });\n};\n\n/**\n * Merges the value of `conf` with the passed `cnf`\n *\n * @param cnf - Config to merge\n */\nexport const setConf = function (cnf: any) {\n  conf = {\n    ...conf,\n    ...cnf,\n  };\n};\n\n/**\n * Draws a class diagram in the tag with id: id based on the definition in text.\n *\n * @param text -\n * @param id -\n * @param _version -\n * @param diagObj -\n */\nexport const draw = async function (text: string, id: string, _version: string, diagObj: any) {\n  log.info('Drawing class - ', id);\n\n  // TODO V10: Why flowchart? Might be a mistake when copying.\n  const conf = getConfig().flowchart ?? getConfig().class;\n  const securityLevel = getConfig().securityLevel;\n  log.info('config:', conf);\n  const nodeSpacing = conf?.nodeSpacing ?? 50;\n  const rankSpacing = conf?.rankSpacing ?? 50;\n\n  // Create the input mermaid.graph\n  const g: graphlib.Graph = new graphlib.Graph({\n    multigraph: true,\n    compound: true,\n  })\n    .setGraph({\n      rankdir: diagObj.db.getDirection(),\n      nodesep: nodeSpacing,\n      ranksep: rankSpacing,\n      marginx: 8,\n      marginy: 8,\n    })\n    .setDefaultEdgeLabel(function () {\n      return {};\n    });\n\n  // Fetch the vertices/nodes and edges/links from the parsed graph definition\n  const namespaces: NamespaceMap = diagObj.db.getNamespaces();\n  const classes: ClassMap = diagObj.db.getClasses();\n  const relations: ClassRelation[] = diagObj.db.getRelations();\n  const notes: ClassNote[] = diagObj.db.getNotes();\n  log.info(relations);\n  addNamespaces(namespaces, g, id, diagObj);\n  addClasses(classes, g, id, diagObj);\n  addRelations(relations, g);\n  addNotes(notes, g, relations.length + 1, classes);\n\n  // Set up an SVG group so that we can translate the final graph.\n  let sandboxElement;\n  if (securityLevel === 'sandbox') {\n    sandboxElement = select('#i' + id);\n  }\n  const root =\n    securityLevel === 'sandbox'\n      ? select(sandboxElement.nodes()[0]!.contentDocument.body)\n      : select('body');\n  const svg = root.select(`[id=\"${id}\"]`);\n\n  // Run the renderer. This is what draws the final graph.\n  const element = root.select('#' + id + ' g');\n  await render(\n    element,\n    g,\n    ['aggregation', 'extension', 'composition', 'dependency', 'lollipop'],\n    'classDiagram',\n    id\n  );\n\n  utils.insertTitle(svg, 'classTitleText', conf?.titleTopMargin ?? 5, diagObj.db.getDiagramTitle());\n\n  setupGraphViewbox(g, svg, conf?.diagramPadding, conf?.useMaxWidth);\n\n  // Add label rects for non html labels\n  if (!conf?.htmlLabels) {\n    const doc = securityLevel === 'sandbox' ? sandboxElement.nodes()[0]!.contentDocument : document;\n    const labels = doc.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n    for (const label of labels) {\n      // Get dimensions of label\n      const dim = label.getBBox();\n\n      const rect = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      rect.setAttribute('rx', 0);\n      rect.setAttribute('ry', 0);\n      rect.setAttribute('width', dim.width);\n      rect.setAttribute('height', dim.height);\n\n      label.insertBefore(rect, label.firstChild);\n    }\n  }\n};\n\n/**\n * Gets the arrow marker for a type index\n *\n * @param type - The type to look for\n * @returns The arrow marker\n */\nfunction getArrowMarker(type: number) {\n  let marker;\n  switch (type) {\n    case 0:\n      marker = 'aggregation';\n      break;\n    case 1:\n      marker = 'extension';\n      break;\n    case 2:\n      marker = 'composition';\n      break;\n    case 3:\n      marker = 'dependency';\n      break;\n    case 4:\n      marker = 'lollipop';\n      break;\n    default:\n      marker = 'none';\n  }\n  return marker;\n}\n\nexport default {\n  setConf,\n  draw,\n};\n", "import type { DiagramDefinition } from '../../diagram-api/types.js';\n// @ts-ignore: JISON doesn't support types\nimport parser from './parser/classDiagram.jison';\nimport db from './classDb.js';\nimport styles from './styles.js';\nimport renderer from './classRenderer-v2.js';\n\nexport const diagram: DiagramDefinition = {\n  parser,\n  db,\n  renderer,\n  styles,\n  init: (cnf) => {\n    if (!cnf.class) {\n      cnf.class = {};\n    }\n    cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    db.clear();\n  },\n};\n"],
  "mappings": "mtBAKO,IAAIA,EAAY,CAAC,EACpBC,EAAc,CAAC,EACfC,GAAU,CAAC,EAEFC,GAAQC,EAAA,IAAM,CACzBH,EAAc,CAAC,EACfC,GAAU,CAAC,EACXF,EAAY,CAAC,CACf,EAJqB,SAMfK,EAAeD,EAAA,CAACE,EAAIC,KAGxBC,EAAI,MAAM,kBAAmBD,EAAY,IAAKD,EAAI,MAAOL,EAAYM,CAAU,EAAE,SAASD,CAAE,CAAC,EACzF,EAAAL,EAAYM,CAAU,EAAE,SAASD,CAAE,GAJpB,gBAWfG,GAAgBL,EAAA,CAACM,EAAMC,KAC3BH,EAAI,KAAK,kBAAmBG,EAAW,OAAQV,EAAYU,CAAS,CAAC,EACrEH,EAAI,KAAK,WAAYE,CAAI,EAErBA,EAAK,IAAMC,GAGXD,EAAK,IAAMC,EACN,GAGJV,EAAYU,CAAS,EAKxBV,EAAYU,CAAS,EAAE,SAASD,EAAK,CAAC,GACtCL,EAAaK,EAAK,EAAGC,CAAS,GAC9BN,EAAaK,EAAK,EAAGC,CAAS,GAC9BV,EAAYU,CAAS,EAAE,SAASD,EAAK,CAAC,GAPtCF,EAAI,MAAM,SAAUG,EAAW,qBAAqB,EAC7C,KAbW,iBAuBhBC,GAAOR,EAAA,CAACO,EAAWE,EAAOC,EAAUC,IAAW,CACnDP,EAAI,KACF,uBACAG,EACA,OACAI,EACA,OACAF,EAAM,KAAKF,CAAS,EACpBI,CACF,EACA,IAAMC,EAAQH,EAAM,SAASF,CAAS,GAAK,CAAC,EAGxCA,IAAcI,GAChBC,EAAM,KAAKL,CAAS,EAGtBH,EAAI,KAAK,4BAA6BG,EAAW,QAASK,CAAK,EAE/DA,EAAM,QAASC,GAAS,CACtB,GAAIJ,EAAM,SAASI,CAAI,EAAE,OAAS,EAChCL,GAAKK,EAAMJ,EAAOC,EAAUC,CAAM,MAC7B,CACL,IAAMG,EAAOL,EAAM,KAAKI,CAAI,EAC5BT,EAAI,KAAK,MAAOS,EAAM,OAAQF,EAAQ,gBAAiBJ,CAAS,EAChEG,EAAS,QAAQG,EAAMC,CAAI,EACvBH,IAAWF,EAAM,OAAOI,CAAI,IAC9BT,EAAI,KAAK,iBAAkBS,EAAMJ,EAAM,OAAOI,CAAI,CAAC,EACnDH,EAAS,UAAUG,EAAMJ,EAAM,OAAOI,CAAI,CAAC,GAGzCN,IAAcI,GAAUE,IAASN,GACnCH,EAAI,MAAM,iBAAkBS,EAAMN,CAAS,EAC3CG,EAAS,UAAUG,EAAMN,CAAS,IAElCH,EAAI,KAAK,WAAYG,EAAW,OAAQI,EAAQ,OAAQF,EAAM,KAAKF,CAAS,EAAGI,CAAM,EACrFP,EAAI,MACF,+BACAS,EACA,mBACAN,IAAcI,EACd,mBACAE,IAASN,CACX,GAEF,IAAMQ,EAAQN,EAAM,MAAMI,CAAI,EAC9BT,EAAI,MAAM,gBAAiBW,CAAK,EAChCA,EAAM,QAAST,GAAS,CACtBF,EAAI,KAAK,OAAQE,CAAI,EACrB,IAAMQ,EAAOL,EAAM,KAAKH,EAAK,EAAGA,EAAK,EAAGA,EAAK,IAAI,EACjDF,EAAI,KAAK,YAAaU,EAAMH,CAAM,EAClC,GAAI,CAEEN,GAAcC,EAAMK,CAAM,GAC5BP,EAAI,KAAK,cAAeE,EAAK,EAAGA,EAAK,EAAGQ,EAAMR,EAAK,IAAI,EACvDI,EAAS,QAAQJ,EAAK,EAAGA,EAAK,EAAGQ,EAAMR,EAAK,IAAI,EAChDF,EAAI,KAAK,kBAAmBM,EAAS,MAAM,EAAGA,EAAS,KAAKA,EAAS,MAAM,EAAE,CAAC,CAAC,CAAC,GAEhFN,EAAI,KACF,yBACAE,EAAK,EACL,MACAA,EAAK,EACL,YACAK,EACA,cACAJ,CACF,CAEJ,OAASS,EAAG,CACVZ,EAAI,MAAMY,CAAC,CACb,CACF,CAAC,CACH,CACAZ,EAAI,MAAM,gBAAiBS,CAAI,EAC/BJ,EAAM,WAAWI,CAAI,CACvB,CAAC,CACH,EA7Ea,QA8EAI,GAAqBjB,EAAA,CAACE,EAAIO,IAAU,CAE/C,IAAMS,EAAWT,EAAM,SAASP,CAAE,EAC9BiB,EAAM,CAAC,GAAGD,CAAQ,EAEtB,QAAWE,KAASF,EAClBpB,GAAQsB,CAAK,EAAIlB,EACjBiB,EAAM,CAAC,GAAGA,EAAK,GAAGF,GAAmBG,EAAOX,CAAK,CAAC,EAGpD,OAAOU,CACT,EAXkC,sBAyC3B,IAAME,EAAsBC,EAAA,CAACC,EAAIC,IAAU,CAEhDC,EAAI,MAAM,YAAaF,CAAE,EAEzB,IAAMG,EAAWF,EAAM,SAASD,CAAE,EAElC,GADAE,EAAI,MAAM,4BAA6BF,EAAIG,CAAQ,EAC/CA,EAAS,OAAS,EACpB,OAAAD,EAAI,MAAM,uBAAwBF,CAAE,EAC7BA,EAET,QAAWI,KAASD,EAAU,CAC5B,IAAME,EAAMP,EAAoBM,EAAOH,CAAK,EAC5C,GAAII,EACF,OAAAH,EAAI,MAAM,wBAAyBF,EAAI,OAAQK,CAAG,EAC3CA,CAEX,CACF,EAjBmC,uBAmB7BC,EAAcP,EAACC,GACf,CAACO,EAAUP,CAAE,GAIb,CAACO,EAAUP,CAAE,EAAE,oBACVA,EAILO,EAAUP,CAAE,EACPO,EAAUP,CAAE,EAAE,GAEhBA,EAbW,eAgBPQ,GAAyBT,EAAA,CAACE,EAAOQ,IAAU,CACtD,GAAI,CAACR,GAASQ,EAAQ,GAAI,CACxBP,EAAI,MAAM,uBAAuB,EACjC,MACF,MACEA,EAAI,MAAM,mBAAmB,EAI/BD,EAAM,MAAM,EAAE,QAAQ,SAAUD,EAAI,CACjBC,EAAM,SAASD,CAAE,EACrB,OAAS,IACpBE,EAAI,KACF,qBACAF,EACA,6BACAF,EAAoBE,EAAIC,CAAK,CAC/B,EACAS,EAAYV,CAAE,EAAIW,GAAmBX,EAAIC,CAAK,EAC9CM,EAAUP,CAAE,EAAI,CAAE,GAAIF,EAAoBE,EAAIC,CAAK,EAAG,YAAaA,EAAM,KAAKD,CAAE,CAAE,EAEtF,CAAC,EAGDC,EAAM,MAAM,EAAE,QAAQ,SAAUD,EAAI,CAClC,IAAMG,EAAWF,EAAM,SAASD,CAAE,EAC5BY,EAAQX,EAAM,MAAM,EACtBE,EAAS,OAAS,GACpBD,EAAI,MAAM,qBAAsBF,EAAIU,CAAW,EAC/CE,EAAM,QAASC,GAAS,CAItB,GAAIA,EAAK,IAAMb,GAAMa,EAAK,IAAMb,EAAI,CAIlC,IAAMc,EAAKC,EAAaF,EAAK,EAAGb,CAAE,EAC5BgB,EAAKD,EAAaF,EAAK,EAAGb,CAAE,EAG9Bc,EAAKE,IACPd,EAAI,KAAK,SAAUW,EAAM,mBAAoBb,CAAE,EAC/CE,EAAI,KAAK,sBAAuBF,EAAI,KAAMU,EAAYV,CAAE,CAAC,EACzDO,EAAUP,CAAE,EAAE,oBAAsB,GAExC,CACF,CAAC,GAEDE,EAAI,MAAM,iBAAkBF,EAAIU,CAAW,CAE/C,CAAC,EAED,QAASV,KAAM,OAAO,KAAKO,CAAS,EAAG,CACrC,IAAMU,EAAkBV,EAAUP,CAAE,EAAE,GAChCkB,EAASjB,EAAM,OAAOgB,CAAe,EAGvCC,IAAWlB,GAAMO,EAAUW,CAAM,GAAK,CAACX,EAAUW,CAAM,EAAE,sBAC3DX,EAAUP,CAAE,EAAE,GAAKkB,EAEvB,CAIAjB,EAAM,MAAM,EAAE,QAAQ,SAAUkB,EAAG,CACjC,IAAMN,EAAOZ,EAAM,KAAKkB,CAAC,EACzBjB,EAAI,KAAK,QAAUiB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAO,KAAK,UAAUA,CAAC,CAAC,EAChEjB,EAAI,KAAK,QAAUiB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAO,KAAK,UAAUlB,EAAM,KAAKkB,CAAC,CAAC,CAAC,EAE5E,IAAIC,EAAID,EAAE,EACNE,EAAIF,EAAE,EAaV,GAXAjB,EAAI,KACF,UACAK,EACA,OACAY,EAAE,EACFA,EAAE,EACF,gBACAZ,EAAUY,EAAE,CAAC,EACb,QACAZ,EAAUY,EAAE,CAAC,CACf,EACIZ,EAAUY,EAAE,CAAC,GAAKZ,EAAUY,EAAE,CAAC,GAAKZ,EAAUY,EAAE,CAAC,IAAMZ,EAAUY,EAAE,CAAC,EAAG,CAEzEjB,EAAI,KAAK,iDAAkDiB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EAC3EjB,EAAI,KAAK,oCAAqCiB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EAC9DC,EAAId,EAAYa,EAAE,CAAC,EACnBE,EAAIf,EAAYa,EAAE,CAAC,EACnBlB,EAAM,WAAWkB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EACjC,IAAMG,EAAYH,EAAE,EAAI,MAAQA,EAAE,EAClClB,EAAM,QAAQqB,EAAW,CACvB,MAAOA,EACP,GAAIA,EACJ,WAAY,GACZ,UAAWT,EAAK,MAChB,QAAS,EACT,MAAO,YACP,MAAO,EACT,CAAC,EACD,IAAMU,EAAQ,gBAAgBV,CAAI,EAC5BW,EAAQ,gBAAgBX,CAAI,EAClCU,EAAM,MAAQ,GACdA,EAAM,aAAe,OACrBC,EAAM,MAAQ,GACdD,EAAM,YAAcJ,EAAE,EACtBK,EAAM,UAAYL,EAAE,EAEpBlB,EAAM,QAAQmB,EAAGE,EAAWC,EAAOJ,EAAE,KAAO,iBAAiB,EAC7DlB,EAAM,QAAQqB,EAAWD,EAAGG,EAAOL,EAAE,KAAO,iBAAiB,CAC/D,SAAWZ,EAAUY,EAAE,CAAC,GAAKZ,EAAUY,EAAE,CAAC,EAAG,CAK3C,GAJAjB,EAAI,KAAK,oCAAqCiB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EAC9DC,EAAId,EAAYa,EAAE,CAAC,EACnBE,EAAIf,EAAYa,EAAE,CAAC,EACnBlB,EAAM,WAAWkB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EAC7BC,IAAMD,EAAE,EAAG,CACb,IAAMD,EAASjB,EAAM,OAAOmB,CAAC,EAC7Bb,EAAUW,CAAM,EAAE,oBAAsB,GACxCL,EAAK,YAAcM,EAAE,CACvB,CACA,GAAIE,IAAMF,EAAE,EAAG,CACb,IAAMD,EAASjB,EAAM,OAAOoB,CAAC,EAC7Bd,EAAUW,CAAM,EAAE,oBAAsB,GACxCL,EAAK,UAAYM,EAAE,CACrB,CACAjB,EAAI,KAAK,yBAA0BkB,EAAGC,EAAGF,EAAE,IAAI,EAC/ClB,EAAM,QAAQmB,EAAGC,EAAGR,EAAMM,EAAE,IAAI,CAClC,CACF,CAAC,EACDjB,EAAI,KAAK,iBAA+BuB,EAAMxB,CAAK,CAAC,EACpDyB,GAAUzB,EAAO,CAAC,EAElBC,EAAI,MAAMK,CAAS,CAQrB,EA7IsC,0BA+IzBmB,GAAY3B,EAAA,CAACE,EAAOQ,IAAU,CAEzC,GADAP,EAAI,KAAK,eAAgBO,EAAoBgB,EAAMxB,CAAK,EAAGA,EAAM,SAAS,GAAG,CAAC,EAC1EQ,EAAQ,GAAI,CACdP,EAAI,MAAM,aAAa,EACvB,MACF,CAIA,IAAIyB,EAAQ1B,EAAM,MAAM,EACpB2B,EAAc,GAClB,QAAWC,KAAQF,EAAO,CACxB,IAAMxB,EAAWF,EAAM,SAAS4B,CAAI,EACpCD,EAAcA,GAAezB,EAAS,OAAS,CACjD,CAEA,GAAI,CAACyB,EAAa,CAChB1B,EAAI,MAAM,6BAA8BD,EAAM,MAAM,CAAC,EACrD,MACF,CAGAC,EAAI,MAAM,WAAYyB,EAAOlB,CAAK,EAClC,QAAWoB,KAAQF,EAcjB,GAbAzB,EAAI,MACF,kBACA2B,EACAtB,EACAA,EAAUsB,CAAI,GAAK,CAACtB,EAAUsB,CAAI,EAAE,oBACpC,CAAC5B,EAAM,OAAO4B,CAAI,EAClB5B,EAAM,KAAK4B,CAAI,EACf5B,EAAM,SAAS,GAAG,EAClB,UACAQ,CACF,EAGI,CAACF,EAAUsB,CAAI,EAEjB3B,EAAI,MAAM,gBAAiB2B,EAAMpB,CAAK,UAGtC,CAACF,EAAUsB,CAAI,EAAE,qBAEjB5B,EAAM,SAAS4B,CAAI,GACnB5B,EAAM,SAAS4B,CAAI,EAAE,OAAS,EAC9B,CACA3B,EAAI,KACF,2EACA2B,EACApB,CACF,EAGA,IAAIqB,EADkB7B,EAAM,MAAM,EACV,UAAY,KAAO,KAAO,KAC9CM,EAAUsB,CAAI,GAAG,aAAa,MAChCC,EAAMvB,EAAUsB,CAAI,EAAE,YAAY,IAClC3B,EAAI,KAAK,aAAcK,EAAUsB,CAAI,EAAE,YAAY,IAAKC,CAAG,GAG7D,IAAMC,EAAe,IAAaC,EAAM,CACtC,WAAY,GACZ,SAAU,EACZ,CAAC,EACE,SAAS,CACR,QAASF,EACT,QAAS,GACT,QAAS,GACT,QAAS,EACT,QAAS,CACX,CAAC,EACA,oBAAoB,UAAY,CAC/B,MAAO,CAAC,CACV,CAAC,EAEH5B,EAAI,KAAK,wBAAsCuB,EAAMxB,CAAK,CAAC,EAC3DgC,GAAKJ,EAAM5B,EAAO8B,EAAcF,CAAI,EACpC5B,EAAM,QAAQ4B,EAAM,CAClB,YAAa,GACb,GAAIA,EACJ,YAAatB,EAAUsB,CAAI,EAAE,YAC7B,UAAWtB,EAAUsB,CAAI,EAAE,UAC3B,MAAOE,CACT,CAAC,EACD7B,EAAI,KAAK,+BAAgC2B,EAAM,IAAkBJ,EAAMM,CAAY,CAAC,EACpF7B,EAAI,MAAM,uBAAqCuB,EAAMxB,CAAK,CAAC,CAC7D,MACEC,EAAI,KACF,cACA2B,EACA,oDACA,CAACtB,EAAUsB,CAAI,EAAE,oBACjB,eACA,CAAC5B,EAAM,OAAO4B,CAAI,EAClB,aACA5B,EAAM,SAAS4B,CAAI,GAAK5B,EAAM,SAAS4B,CAAI,EAAE,OAAS,EACtD5B,EAAM,SAAS,GAAG,EAClBQ,CACF,EACAP,EAAI,MAAMK,CAAS,EAIvBoB,EAAQ1B,EAAM,MAAM,EACpBC,EAAI,KAAK,oBAAqByB,CAAK,EACnC,QAAWE,KAAQF,EAAO,CACxB,IAAMO,EAAOjC,EAAM,KAAK4B,CAAI,EAC5B3B,EAAI,KAAK,kBAAmB2B,EAAMK,CAAI,EAClCA,EAAK,aACPR,GAAUQ,EAAK,MAAOzB,EAAQ,CAAC,CAEnC,CACF,EAhHyB,aAkHnB0B,GAASpC,EAAA,CAACE,EAAO0B,IAAU,CAC/B,GAAIA,EAAM,SAAW,EACnB,MAAO,CAAC,EAEV,IAAIS,EAAS,OAAO,OAAOT,CAAK,EAChC,OAAAA,EAAM,QAASE,GAAS,CACtB,IAAM1B,EAAWF,EAAM,SAAS4B,CAAI,EAC9BQ,EAASF,GAAOlC,EAAOE,CAAQ,EACrCiC,EAAS,CAAC,GAAGA,EAAQ,GAAGC,CAAM,CAChC,CAAC,EAEMD,CACT,EAZe,UAcFE,GAAuBvC,EAACE,GAAUkC,GAAOlC,EAAOA,EAAM,SAAS,CAAC,EAAzC,wBCjdpC,IAAMsC,GAAOC,EAAA,CAACC,EAAQC,IAAS,CAC7BC,EAAI,KAAK,8BAA+BD,EAAK,GAAIA,CAAI,EACrD,IAAME,EAAaC,EAAU,EAGvBC,EAAWL,EACd,OAAO,GAAG,EACV,KAAK,QAAS,WAAaC,EAAK,MAAQ,IAAMA,EAAK,MAAQ,GAAG,EAC9D,KAAK,KAAMA,EAAK,EAAE,EAGfH,EAAOO,EAAS,OAAO,OAAQ,cAAc,EAE7CC,EAAgBC,EAASJ,EAAW,UAAU,UAAU,EAGxDK,EAAQH,EAAS,OAAO,GAAG,EAAE,KAAK,QAAS,eAAe,EAK1DI,EACJR,EAAK,YAAc,WACfS,EAAWF,EAAOP,EAAK,UAAW,CAAE,MAAOA,EAAK,WAAY,cAAAK,CAAc,EAAGH,CAAU,EACvFK,EAAM,KAAK,EAAE,YAAYG,EAAYV,EAAK,UAAWA,EAAK,WAAY,OAAW,EAAI,CAAC,EAGxFW,EAAOH,EAAK,QAAQ,EAExB,GAAIF,EAASJ,EAAW,UAAU,UAAU,EAAG,CAC7C,IAAMU,EAAMJ,EAAK,SAAS,CAAC,EACrBK,EAAKC,EAAON,CAAI,EACtBG,EAAOC,EAAI,sBAAsB,EACjCC,EAAG,KAAK,QAASF,EAAK,KAAK,EAC3BE,EAAG,KAAK,SAAUF,EAAK,MAAM,CAC/B,CAEA,IAAMI,EAAU,EAAIf,EAAK,QACnBgB,EAAcD,EAAU,EAExBE,EAAQjB,EAAK,OAASW,EAAK,MAAQI,EAAUJ,EAAK,MAAQI,EAAUf,EAAK,MAC3EA,EAAK,OAASW,EAAK,MAAQI,EAC7Bf,EAAK,MAAQW,EAAK,MAAQX,EAAK,OAAS,EAAIA,EAAK,QAAU,EAE3DA,EAAK,KAAO,CAACA,EAAK,QAAU,EAG9BC,EAAI,MAAM,QAASD,EAAM,KAAK,UAAUA,CAAI,CAAC,EAE7CH,EACG,KAAK,QAASG,EAAK,KAAK,EACxB,KAAK,KAAMA,EAAK,EAAE,EAClB,KAAK,KAAMA,EAAK,EAAE,EAClB,KAAK,IAAKA,EAAK,EAAIiB,EAAQ,CAAC,EAC5B,KAAK,IAAKjB,EAAK,EAAIA,EAAK,OAAS,EAAIgB,CAAW,EAChD,KAAK,QAASC,CAAK,EACnB,KAAK,SAAUjB,EAAK,OAASe,CAAO,EAEvC,GAAM,CAAE,uBAAAG,CAAuB,EAAIC,EAAwBjB,CAAU,EACjEG,EACFE,EAAM,KACJ,YAEA,aAAaP,EAAK,EAAIW,EAAK,MAAQ,CAAC,KAAKX,EAAK,EAAIA,EAAK,OAAS,EAAIkB,CAAsB,GAC5F,EAEAX,EAAM,KACJ,YAEA,aAAaP,EAAK,CAAC,KAAKA,EAAK,EAAIA,EAAK,OAAS,EAAIkB,CAAsB,GAC3E,EAIF,IAAME,EAAUvB,EAAK,KAAK,EAAE,QAAQ,EACpC,OAAAG,EAAK,MAAQoB,EAAQ,MACrBpB,EAAK,OAASoB,EAAQ,OAEtBpB,EAAK,UAAY,SAAUqB,EAAO,CAChC,OAAOC,EAActB,EAAMqB,CAAK,CAClC,EAEOjB,CACT,EAnFa,QA4FPmB,GAAYzB,EAAA,CAACC,EAAQC,IAAS,CAElC,IAAMI,EAAWL,EAAO,OAAO,GAAG,EAAE,KAAK,QAAS,cAAc,EAAE,KAAK,KAAMC,EAAK,EAAE,EAG9EH,EAAOO,EAAS,OAAO,OAAQ,cAAc,EAE7CW,EAAU,EAAIf,EAAK,QACnBgB,EAAcD,EAAU,EAG9BlB,EACG,KAAK,KAAMG,EAAK,EAAE,EAClB,KAAK,KAAMA,EAAK,EAAE,EAClB,KAAK,IAAKA,EAAK,EAAIA,EAAK,MAAQ,EAAIgB,CAAW,EAC/C,KAAK,IAAKhB,EAAK,EAAIA,EAAK,OAAS,EAAIgB,CAAW,EAChD,KAAK,QAAShB,EAAK,MAAQe,CAAO,EAClC,KAAK,SAAUf,EAAK,OAASe,CAAO,EACpC,KAAK,OAAQ,MAAM,EAEtB,IAAMK,EAAUvB,EAAK,KAAK,EAAE,QAAQ,EACpC,OAAAG,EAAK,MAAQoB,EAAQ,MACrBpB,EAAK,OAASoB,EAAQ,OAEtBpB,EAAK,UAAY,SAAUqB,EAAO,CAChC,OAAOC,EAActB,EAAMqB,CAAK,CAClC,EAEOjB,CACT,EA7BkB,aA8BZoB,GAAmB1B,EAAA,CAACC,EAAQC,IAAS,CACzC,IAAME,EAAaC,EAAU,EAGvBC,EAAWL,EAAO,OAAO,GAAG,EAAE,KAAK,QAASC,EAAK,OAAO,EAAE,KAAK,KAAMA,EAAK,EAAE,EAG5EH,EAAOO,EAAS,OAAO,OAAQ,cAAc,EAG7CG,EAAQH,EAAS,OAAO,GAAG,EAAE,KAAK,QAAS,eAAe,EAC1DqB,EAAYrB,EAAS,OAAO,MAAM,EAElCI,EAAOD,EACV,KAAK,EACL,YAAYG,EAAYV,EAAK,UAAWA,EAAK,WAAY,OAAW,EAAI,CAAC,EAGxEW,EAAOH,EAAK,QAAQ,EACxB,GAAIF,EAASJ,EAAW,UAAU,UAAU,EAAG,CAC7C,IAAMU,EAAMJ,EAAK,SAAS,CAAC,EACrBK,EAAKC,EAAON,CAAI,EACtBG,EAAOC,EAAI,sBAAsB,EACjCC,EAAG,KAAK,QAASF,EAAK,KAAK,EAC3BE,EAAG,KAAK,SAAUF,EAAK,MAAM,CAC/B,CACAA,EAAOH,EAAK,QAAQ,EACpB,IAAMO,EAAU,EAAIf,EAAK,QACnBgB,EAAcD,EAAU,EAExBE,EAAQjB,EAAK,OAASW,EAAK,MAAQX,EAAK,QAAUW,EAAK,MAAQX,EAAK,QAAUA,EAAK,MACrFA,EAAK,OAASW,EAAK,MAAQX,EAAK,QAClCA,EAAK,MAAQW,EAAK,MAAQX,EAAK,QAAU,EAAIA,EAAK,OAAS,EAE3DA,EAAK,KAAO,CAACA,EAAK,QAAU,EAI9BH,EACG,KAAK,QAAS,OAAO,EACrB,KAAK,IAAKG,EAAK,EAAIiB,EAAQ,EAAID,CAAW,EAC1C,KAAK,IAAKhB,EAAK,EAAIA,EAAK,OAAS,EAAIgB,CAAW,EAChD,KAAK,QAASC,EAAQF,CAAO,EAC7B,KAAK,SAAUf,EAAK,OAASe,CAAO,EACvCU,EACG,KAAK,QAAS,OAAO,EACrB,KAAK,IAAKzB,EAAK,EAAIiB,EAAQ,EAAID,CAAW,EAC1C,KAAK,IAAKhB,EAAK,EAAIA,EAAK,OAAS,EAAIgB,EAAcL,EAAK,OAAS,CAAC,EAClE,KAAK,QAASM,EAAQF,CAAO,EAC7B,KAAK,SAAUf,EAAK,OAASe,EAAUJ,EAAK,OAAS,CAAC,EAEzD,GAAM,CAAE,uBAAAO,CAAuB,EAAIC,EAAwBjB,CAAU,EAErEK,EAAM,KACJ,YACA,aAAaP,EAAK,EAAIW,EAAK,MAAQ,CAAC,KAClCX,EAAK,EACLA,EAAK,OAAS,EACdA,EAAK,QAAU,GACdM,EAASJ,EAAW,UAAU,UAAU,EAAI,EAAI,GACjDgB,CACF,GACF,EAEA,IAAME,EAAUvB,EAAK,KAAK,EAAE,QAAQ,EACpC,OAAAG,EAAK,OAASoB,EAAQ,OAEtBpB,EAAK,UAAY,SAAUqB,EAAO,CAChC,OAAOC,EAActB,EAAMqB,CAAK,CAClC,EAEOjB,CACT,EAxEyB,oBA0EnBsB,GAAU5B,EAAA,CAACC,EAAQC,IAAS,CAEhC,IAAMI,EAAWL,EAAO,OAAO,GAAG,EAAE,KAAK,QAASC,EAAK,OAAO,EAAE,KAAK,KAAMA,EAAK,EAAE,EAG5EH,EAAOO,EAAS,OAAO,OAAQ,cAAc,EAE7CW,EAAU,EAAIf,EAAK,QACnBgB,EAAcD,EAAU,EAG9BlB,EACG,KAAK,QAAS,SAAS,EACvB,KAAK,IAAKG,EAAK,EAAIA,EAAK,MAAQ,EAAIgB,CAAW,EAC/C,KAAK,IAAKhB,EAAK,EAAIA,EAAK,OAAS,CAAC,EAClC,KAAK,QAASA,EAAK,MAAQe,CAAO,EAClC,KAAK,SAAUf,EAAK,OAASe,CAAO,EAEvC,IAAMK,EAAUvB,EAAK,KAAK,EAAE,QAAQ,EACpC,OAAAG,EAAK,MAAQoB,EAAQ,MACrBpB,EAAK,OAASoB,EAAQ,OACtBpB,EAAK,KAAO,CAACA,EAAK,QAAU,EAC5BA,EAAK,UAAY,SAAUqB,EAAO,CAChC,OAAOC,EAActB,EAAMqB,CAAK,CAClC,EAEOjB,CACT,EA3BgB,WA6BVuB,GAAS,CAAE,KAAA9B,GAAM,iBAAA2B,GAAkB,UAAAD,GAAW,QAAAG,EAAQ,EAExDE,GAAe,CAAC,EAEPC,GAAgB/B,EAAA,CAACgC,EAAM9B,IAAS,CAC3CC,EAAI,MAAM,mBAAmB,EAC7B,IAAM8B,EAAQ/B,EAAK,OAAS,OAC5B4B,GAAa5B,EAAK,EAAE,EAAI2B,GAAOI,CAAK,EAAED,EAAM9B,CAAI,CAClD,EAJ6B,iBAatB,IAAMgC,GAAQC,EAAA,IAAM,CACzBC,GAAe,CAAC,CAClB,EAFqB,SCzOrB,IAAMC,GAAkBC,EAAA,MAAOC,EAAOC,EAAOC,EAAaC,EAAIC,EAAeC,IAAe,CAC1FC,EAAI,KAAK,iCAA+CC,EAAMN,CAAK,EAAGG,CAAa,EACnF,IAAMI,EAAMP,EAAM,MAAM,EAAE,QAC1BK,EAAI,MAAM,iCAAkCE,CAAG,EAE/C,IAAMC,EAAOT,EAAM,OAAO,GAAG,EAAE,KAAK,QAAS,MAAM,EAC9CC,EAAM,MAAM,EAGfK,EAAI,KAAK,uBAAwBL,EAAM,MAAM,CAAC,EAF9CK,EAAI,KAAK,qBAAsBL,CAAK,EAIlCA,EAAM,MAAM,EAAE,OAAS,GACzBK,EAAI,MAAM,kBAAmBL,EAAM,KAAKA,EAAM,MAAM,EAAE,CAAC,CAAC,CAAC,EAE3D,IAAMS,EAAWD,EAAK,OAAO,GAAG,EAAE,KAAK,QAAS,UAAU,EACpDE,EAAYF,EAAK,OAAO,GAAG,EAAE,KAAK,QAAS,WAAW,EACtDG,EAAaH,EAAK,OAAO,GAAG,EAAE,KAAK,QAAS,YAAY,EACxDI,EAAQJ,EAAK,OAAO,GAAG,EAAE,KAAK,QAAS,OAAO,EAIpD,MAAM,QAAQ,IACZR,EAAM,MAAM,EAAE,IAAI,eAAgBa,EAAG,CACnC,IAAMC,EAAOd,EAAM,KAAKa,CAAC,EACzB,GAAIV,IAAkB,OAAW,CAC/B,IAAMY,EAAO,KAAK,MAAM,KAAK,UAAUZ,EAAc,WAAW,CAAC,EAEjEE,EAAI,KAAK,iCAAkCQ,EAAG,KAAME,EAAMZ,CAAa,EACvEH,EAAM,QAAQG,EAAc,GAAIY,CAAI,EAC/Bf,EAAM,OAAOa,CAAC,IACjBR,EAAI,MAAM,iBAAkBQ,EAAGV,EAAc,EAAE,EAC/CH,EAAM,UAAUa,EAAGV,EAAc,GAAIY,CAAI,EAE7C,CAEA,GADAV,EAAI,KAAK,oBAAsBQ,EAAI,KAAO,KAAK,UAAUb,EAAM,KAAKa,CAAC,CAAC,CAAC,EACnEC,GAAM,YAAa,CAErBT,EAAI,KAAK,qBAAsBQ,EAAGC,EAAK,MAAOd,EAAM,KAAKa,CAAC,CAAC,EAG3D,GAAM,CAAE,QAAAG,EAAS,QAAAC,CAAQ,EAAIjB,EAAM,MAAM,EACzCc,EAAK,MAAM,SAAS,CAClB,GAAGA,EAAK,MAAM,MAAM,EACpB,QAAAE,EACA,QAAAC,CACF,CAAC,EACD,IAAMC,EAAI,MAAMrB,GACde,EACAE,EAAK,MACLb,EACAC,EACAF,EAAM,KAAKa,CAAC,EACZT,CACF,EACMe,EAAQD,EAAE,KAChBE,EAAiBN,EAAMK,CAAK,EAC5BL,EAAK,KAAOI,EAAE,MAAQ,EACtBb,EAAI,KAAK,uBAAwBQ,EAAGC,EAAMA,EAAK,MAAOA,EAAK,EAAGA,EAAK,CAAC,EACpEO,EAAYF,EAAOL,CAAI,EAEvBT,EAAI,KAAK,6BAA8Bc,EAAOL,CAAI,CACpD,MACMd,EAAM,SAASa,CAAC,EAAE,OAAS,GAG7BR,EAAI,KAAK,uCAAwCQ,EAAGC,EAAK,GAAIA,EAAMd,CAAK,EACxEK,EAAI,KAAKiB,EAAoBR,EAAK,GAAId,CAAK,CAAC,EAC5CuB,EAAUT,EAAK,EAAE,EAAI,CAAE,GAAIQ,EAAoBR,EAAK,GAAId,CAAK,EAAG,KAAAc,CAAK,IAGrET,EAAI,KAAK,gCAAiCQ,EAAGC,EAAK,GAAIA,CAAI,EAC1D,MAAMU,EAAWZ,EAAOZ,EAAM,KAAKa,CAAC,EAAGN,CAAG,EAGhD,CAAC,CACH,EAMAP,EAAM,MAAM,EAAE,QAAQ,eAAgByB,EAAG,CACvC,IAAMC,EAAO1B,EAAM,KAAKyB,EAAE,EAAGA,EAAE,EAAGA,EAAE,IAAI,EACxCpB,EAAI,KAAK,QAAUoB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAO,KAAK,UAAUA,CAAC,CAAC,EAChEpB,EAAI,KAAK,QAAUoB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAMA,EAAG,IAAK,KAAK,UAAUzB,EAAM,KAAKyB,CAAC,CAAC,CAAC,EAGnFpB,EAAI,KAAK,MAAOkB,EAAW,OAAQE,EAAE,EAAGA,EAAE,EAAG,gBAAiBF,EAAUE,EAAE,CAAC,EAAGF,EAAUE,EAAE,CAAC,CAAC,EAC5F,MAAME,GAAgBhB,EAAYe,CAAI,CACxC,CAAC,EAED1B,EAAM,MAAM,EAAE,QAAQ,SAAUyB,EAAG,CACjCpB,EAAI,KAAK,QAAUoB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAO,KAAK,UAAUA,CAAC,CAAC,CAClE,CAAC,EACDpB,EAAI,KAAK,uBAAwB,KAAK,UAAuBC,EAAMN,CAAK,CAAC,CAAC,EAC1EK,EAAI,KAAK,+CAA+C,EACxDA,EAAI,KAAK,+CAA+C,EACxDA,EAAI,KAAK,+CAA+C,EACxDA,EAAI,KAAKL,CAAK,EACd4B,EAAY5B,CAAK,EACjBK,EAAI,KAAK,sBAAuB,KAAK,UAAuBC,EAAMN,CAAK,CAAC,CAAC,EAEzE,IAAI6B,EAAO,EACL,CAAE,yBAAAC,CAAyB,EAAIC,EAAwB3B,CAAU,EACvE,OAAA4B,GAAqBhC,CAAK,EAAE,QAAQ,SAAUa,EAAG,CAC/C,IAAMC,EAAOd,EAAM,KAAKa,CAAC,EACzBR,EAAI,KAAK,YAAcQ,EAAI,KAAO,KAAK,UAAUb,EAAM,KAAKa,CAAC,CAAC,CAAC,EAC/DR,EAAI,KACF,YAAcQ,EAAI,MAAQC,EAAK,EAC/B,IAAMA,EAAK,EACX,YACAA,EAAK,MACL,YACAA,EAAK,MACP,EACIA,GAAM,aAERA,EAAK,GAAKgB,EACVG,EAAanB,CAAI,GAGbd,EAAM,SAASa,CAAC,EAAE,OAAS,GAG7BC,EAAK,QAAUgB,EACfI,GAAczB,EAAUK,CAAI,EAC5BS,EAAUT,EAAK,EAAE,EAAE,KAAOA,IAE1BA,EAAK,GAAKgB,EAA2B,EACrCG,EAAanB,CAAI,EAGvB,CAAC,EAGDd,EAAM,MAAM,EAAE,QAAQ,SAAUyB,EAAG,CACjC,IAAMC,EAAO1B,EAAM,KAAKyB,CAAC,EACzBpB,EAAI,KAAK,QAAUoB,EAAE,EAAI,OAASA,EAAE,EAAI,KAAO,KAAK,UAAUC,CAAI,EAAGA,CAAI,EAEzEA,EAAK,OAAO,QAASS,GAAWA,EAAM,GAAKL,EAA2B,CAAE,EACxE,IAAMM,EAAQC,GAAW3B,EAAWe,EAAGC,EAAMH,EAAWtB,EAAaD,EAAOE,CAAE,EAC9EoC,GAAkBZ,EAAMU,CAAK,CAC/B,CAAC,EAEDpC,EAAM,MAAM,EAAE,QAAQ,SAAUa,EAAG,CACjC,IAAM0B,EAAIvC,EAAM,KAAKa,CAAC,EACtBR,EAAI,KAAKQ,EAAG0B,EAAE,KAAMA,EAAE,IAAI,EACtBA,EAAE,OAAS,UACbV,EAAOU,EAAE,KAEb,CAAC,EACM,CAAE,KAAA/B,EAAM,KAAAqB,CAAK,CACtB,EAxJwB,mBA0JXW,GAAS1C,EAAA,MAAOU,EAAMR,EAAOyC,EAASxC,EAAaC,IAAO,CACrEwC,GAAclC,EAAMiC,EAASxC,EAAaC,CAAE,EAC5CyC,EAAW,EACXA,GAAW,EACXA,GAAc,EACdA,GAAc,EAEdtC,EAAI,KAAK,kBAAmB,KAAK,UAAuBC,EAAMN,CAAK,CAAC,CAAC,EACrE4C,GAAuB5C,CAAK,EAC5BK,EAAI,KAAK,eAAgB,KAAK,UAAuBC,EAAMN,CAAK,CAAC,CAAC,EAElE,IAAMI,EAAayC,EAAU,EAC7B,MAAMhD,GAAgBW,EAAMR,EAAOC,EAAaC,EAAI,OAAWE,CAAU,CAC3E,EAbsB,UC/JtB,IAAM0C,EAAeC,EAACC,GAAgBC,EAAO,aAAaD,EAAKE,EAAU,CAAC,EAArD,gBAEjBC,EAAO,CACT,cAAe,GACf,QAAS,EACT,WAAY,GACZ,MAAO,MACT,EAoBaC,GAAgBL,EAAA,SAC3BM,EACAC,EACAC,EACAC,EACA,CACAC,EAAI,KAAK,QAAS,CAAC,GAAGJ,EAAW,KAAK,CAAC,CAAC,EACxCI,EAAI,KAAKJ,CAAU,EAGnBA,EAAW,QAAQ,SAAUK,EAAQ,CAInC,IAAMC,EAAuB,CAC3B,MAHY,OAIZ,GAAID,EAAO,GACX,MAAOA,EAAO,MACd,UAAWZ,EAAaY,EAAO,EAAE,EACjC,WAAY,GACZ,MAAO,4BAEP,QAASR,EAAU,EAAE,WAAW,SAAWA,EAAU,EAAE,OAAO,OAChE,EAEAI,EAAE,QAAQI,EAAO,GAAIC,CAAI,EACzBC,GAAWF,EAAO,QAASJ,EAAGC,EAAKC,EAASE,EAAO,EAAE,EAErDD,EAAI,KAAK,UAAWE,CAAI,CAC1B,CAAC,CACH,EA9B6B,iBAyChBC,GAAab,EAAA,SACxBc,EACAP,EACAC,EACAC,EACAM,EACA,CACAL,EAAI,KAAK,QAAS,CAAC,GAAGI,EAAQ,KAAK,CAAC,CAAC,EACrCJ,EAAI,KAAKI,CAAO,EAGhB,CAAC,GAAGA,EAAQ,OAAO,CAAC,EACjB,OAAQH,GAAWA,EAAO,SAAWI,CAAM,EAC3C,QAAQ,SAAUJ,EAAQ,CAIzB,IAAMK,EAAcL,EAAO,WAAW,KAAK,GAAG,EAExCM,EAASC,EAAmBP,EAAO,MAAM,EAGzCQ,EAAaR,EAAO,OAASA,EAAO,GACpCS,EAAS,EAITR,EAAO,CACX,WAAYK,EAAO,WACnB,MALY,YAMZ,UAAWlB,EAAaoB,CAAU,EAClC,UAAWR,EACX,GAAIS,EACJ,GAAIA,EACJ,MAAOJ,EACP,MAAOC,EAAO,MACd,GAAIN,EAAO,GACX,MAAOA,EAAO,MACd,QAASF,EAAQ,GAAG,WAAWE,EAAO,GAAII,CAAM,GAAK,GACrD,aAAcJ,EAAO,aACrB,KAAMA,EAAO,KACb,MAAOA,EAAO,OAAS,QAAU,IAAM,OACvC,KAAMA,EAAO,KAEb,QAASR,EAAU,EAAE,WAAW,SAAWA,EAAU,EAAE,OAAO,OAChE,EACAI,EAAE,QAAQI,EAAO,GAAIC,CAAI,EAErBG,GACFR,EAAE,UAAUI,EAAO,GAAII,CAAM,EAG/BL,EAAI,KAAK,UAAWE,CAAI,CAC1B,CAAC,CACL,EAtD0B,cAgEbS,GAAWrB,EAAA,SACtBsB,EACAf,EACAgB,EACAT,EACA,CACAJ,EAAI,KAAKY,CAAK,EAEdA,EAAM,QAAQ,SAAUE,EAAMC,EAAG,CAC/B,IAAMd,EAASa,EAETE,EAAa,GAEbT,EAAS,CAAE,WAAY,GAAI,MAAO,EAAG,EAErCE,EAAaR,EAAO,KAEpBS,EAAS,EAETR,EAAO,CACX,WAAYK,EAAO,WACnB,MAHY,OAIZ,UAAWlB,EAAaoB,CAAU,EAClC,SAAUR,EACV,GAAIS,EACJ,GAAIA,EACJ,MAAOM,EACP,MAAOT,EAAO,MACd,GAAIN,EAAO,GACX,MAAOA,EAAO,GACd,QAAS,GACT,KAAM,OAEN,QAASR,EAAU,EAAE,WAAW,SAAWA,EAAU,EAAE,OAAO,OAChE,EAIA,GAHAI,EAAE,QAAQI,EAAO,GAAIC,CAAI,EACzBF,EAAI,KAAK,UAAWE,CAAI,EAEpB,CAACD,EAAO,OAAS,CAACG,EAAQ,IAAIH,EAAO,KAAK,EAC5C,OAEF,IAAMgB,EAASJ,EAAcE,EAEvBG,EAAqB,CACzB,GAAI,WAAWD,CAAM,GAErB,QAAS,WACT,QAAS,SAET,UAAW,OAEX,gBAAiB,GACjB,aAAc,GAEd,eAAgB,OAChB,aAAc,OACd,MAAO,YACP,WAAY,GACZ,MAAOE,EAAmBzB,EAAK,MAAO0B,CAAW,CACnD,EAGAvB,EAAE,QAAQI,EAAO,GAAIA,EAAO,MAAOiB,EAAUD,CAAM,CACrD,CAAC,CACH,EAhEwB,YAwEXI,GAAe/B,EAAA,SAAUgC,EAA4BzB,EAAmB,CACnF,IAAMH,EAAOD,EAAU,EAAE,UACrB8B,EAAM,EAEVD,EAAU,QAAQ,SAAUE,EAAM,CAChCD,IACA,IAAML,EAAqB,CAEzB,QAAS,WACT,QAASM,EAAK,SAAS,UAAY,EAAI,SAAW,QAClD,GAAIC,EAAUD,EAAK,IAAKA,EAAK,IAAK,CAChC,OAAQ,KACR,QAASD,CACX,CAAC,EAED,UAAWC,EAAK,OAAS,aAAe,OAAS,SAEjD,gBAAiBA,EAAK,iBAAmB,OAAS,GAAKA,EAAK,eAC5D,aAAcA,EAAK,iBAAmB,OAAS,GAAKA,EAAK,eAEzD,eAAgBE,GAAeF,EAAK,SAAS,KAAK,EAClD,aAAcE,GAAeF,EAAK,SAAS,KAAK,EAChD,MAAO,YACP,WAAY,GACZ,MAAOL,EAAmBzB,GAAM,MAAO0B,CAAW,CACpD,EAIA,GAFApB,EAAI,KAAKkB,EAAUM,CAAI,EAEnBA,EAAK,QAAU,OAAW,CAC5B,IAAMjB,EAASC,EAAmBgB,EAAK,KAAK,EAC5CN,EAAS,MAAQX,EAAO,MACxBW,EAAS,WAAaX,EAAO,UAC/B,CAEAiB,EAAK,KAAOA,EAAK,MACbA,EAAK,OAAS,OACZA,EAAK,QAAU,SACjBN,EAAS,eAAiB,eAG5BA,EAAS,eAAiB,aAC1BA,EAAS,SAAW,IAGhBzB,EAAU,EAAE,WAAW,YAAcA,EAAU,EAAE,YACnDyB,EAAS,UAAY,OACrBA,EAAS,MAAQ,2BAA6BM,EAAK,KAAO,YAE1DN,EAAS,UAAY,OACrBA,EAAS,MAAQM,EAAK,KAAK,QAAQhC,EAAO,eAAgB;AAAA,CAAI,EAE1DgC,EAAK,QAAU,SACjBN,EAAS,MAAQA,EAAS,OAAS,+CAGrCA,EAAS,WAAaA,EAAS,WAAW,QAAQ,SAAU,OAAO,IAIvErB,EAAE,QAAQ2B,EAAK,IAAKA,EAAK,IAAKN,EAAUK,CAAG,CAC7C,CAAC,CACH,EA9D4B,gBAqEfI,GAAUrC,EAAA,SAAUsC,EAAU,CACzClC,EAAO,CACL,GAAGA,EACH,GAAGkC,CACL,CACF,EALuB,WAeVC,GAAOvC,EAAA,eAAgBwC,EAAcC,EAAYC,EAAkBjC,EAAc,CAC5FC,EAAI,KAAK,mBAAoB+B,CAAE,EAG/B,IAAMrC,EAAOD,EAAU,EAAE,WAAaA,EAAU,EAAE,MAC5CwC,EAAgBxC,EAAU,EAAE,cAClCO,EAAI,KAAK,UAAWN,CAAI,EACxB,IAAMwC,EAAcxC,GAAM,aAAe,GACnCyC,EAAczC,GAAM,aAAe,GAGnCG,EAAoB,IAAauC,EAAM,CAC3C,WAAY,GACZ,SAAU,EACZ,CAAC,EACE,SAAS,CACR,QAASrC,EAAQ,GAAG,aAAa,EACjC,QAASmC,EACT,QAASC,EACT,QAAS,EACT,QAAS,CACX,CAAC,EACA,oBAAoB,UAAY,CAC/B,MAAO,CAAC,CACV,CAAC,EAGGvC,EAA2BG,EAAQ,GAAG,cAAc,EACpDK,EAAoBL,EAAQ,GAAG,WAAW,EAC1CuB,EAA6BvB,EAAQ,GAAG,aAAa,EACrDa,EAAqBb,EAAQ,GAAG,SAAS,EAC/CC,EAAI,KAAKsB,CAAS,EAClB3B,GAAcC,EAAYC,EAAGkC,EAAIhC,CAAO,EACxCI,GAAWC,EAASP,EAAGkC,EAAIhC,CAAO,EAClCsB,GAAaC,EAAWzB,CAAC,EACzBc,GAASC,EAAOf,EAAGyB,EAAU,OAAS,EAAGlB,CAAO,EAGhD,IAAIiC,EACAJ,IAAkB,YACpBI,EAAiBC,EAAO,KAAOP,CAAE,GAEnC,IAAMQ,EACJN,IAAkB,UACdK,EAAOD,EAAe,MAAM,EAAE,CAAC,EAAG,gBAAgB,IAAI,EACtDC,EAAO,MAAM,EACbE,EAAMD,EAAK,OAAO,QAAQR,CAAE,IAAI,EAGhCU,EAAUF,EAAK,OAAO,IAAMR,EAAK,IAAI,EAc3C,GAbA,MAAMW,GACJD,EACA5C,EACA,CAAC,cAAe,YAAa,cAAe,aAAc,UAAU,EACpE,eACAkC,CACF,EAEAY,EAAM,YAAYH,EAAK,iBAAkB9C,GAAM,gBAAkB,EAAGK,EAAQ,GAAG,gBAAgB,CAAC,EAEhG6C,EAAkB/C,EAAG2C,EAAK9C,GAAM,eAAgBA,GAAM,WAAW,EAG7D,CAACA,GAAM,WAAY,CACrB,IAAMmD,EAAMZ,IAAkB,UAAYI,EAAe,MAAM,EAAE,CAAC,EAAG,gBAAkB,SACjFS,EAASD,EAAI,iBAAiB,QAAUd,EAAK,sBAAsB,EACzE,QAAWgB,KAASD,EAAQ,CAE1B,IAAME,EAAMD,EAAM,QAAQ,EAEpBE,EAAOJ,EAAI,gBAAgB,6BAA8B,MAAM,EACrEI,EAAK,aAAa,KAAM,CAAC,EACzBA,EAAK,aAAa,KAAM,CAAC,EACzBA,EAAK,aAAa,QAASD,EAAI,KAAK,EACpCC,EAAK,aAAa,SAAUD,EAAI,MAAM,EAEtCD,EAAM,aAAaE,EAAMF,EAAM,UAAU,CAC3C,CACF,CACF,EA/EoB,QAuFpB,SAASrB,GAAewB,EAAc,CACpC,IAAIC,EACJ,OAAQD,EAAM,CACZ,IAAK,GACHC,EAAS,cACT,MACF,IAAK,GACHA,EAAS,YACT,MACF,IAAK,GACHA,EAAS,cACT,MACF,IAAK,GACHA,EAAS,aACT,MACF,IAAK,GACHA,EAAS,WACT,MACF,QACEA,EAAS,MACb,CACA,OAAOA,CACT,CAtBS7D,EAAAoC,GAAA,kBAwBT,IAAO0B,GAAQ,CACb,QAAAzB,GACA,KAAAE,EACF,ECxZO,IAAMwB,GAA6B,CACxC,OAAAC,GACA,GAAAC,EACA,SAAAC,GACA,OAAAC,GACA,KAAMC,EAACC,GAAQ,CACRA,EAAI,QACPA,EAAI,MAAQ,CAAC,GAEfA,EAAI,MAAM,oBAAsBA,EAAI,oBACpCJ,EAAG,MAAM,CACX,EANM,OAOR",
  "names": ["clusterDb", "descendants", "parents", "clear", "__name", "isDescendant", "id", "ancestorId", "log", "edgeInCluster", "edge", "clusterId", "copy", "graph", "newGraph", "rootId", "nodes", "node", "data", "edges", "e", "extractDescendants", "children", "res", "child", "findNonClusterChild", "__name", "id", "graph", "log", "children", "child", "_id", "getAnchorId", "clusterDb", "adjustClustersAndEdges", "depth", "descendants", "extractDescendants", "edges", "edge", "d1", "isDescendant", "d2", "nonClusterChild", "parent", "e", "v", "w", "specialId", "edge1", "edge2", "write", "extractor", "nodes", "hasChildren", "node", "dir", "clusterGraph", "Graph", "copy", "data", "sorter", "result", "sorted", "sortNodesByHierarchy", "rect", "__name", "parent", "node", "log", "siteConfig", "getConfig", "shapeSvg", "useHtmlLabels", "evaluate", "label", "text", "createText", "createLabel_default", "bbox", "div", "dv", "select_default", "padding", "halfPadding", "width", "subGraphTitleTopMargin", "getSubGraphTitleMargins", "rectBox", "point", "intersect_rect_default", "noteGroup", "roundedWithTitle", "innerRect", "divider", "shapes", "clusterElems", "insertCluster", "elem", "shape", "clear", "__name", "clusterElems", "recursiveRender", "__name", "_elem", "graph", "diagramType", "id", "parentCluster", "siteConfig", "log", "write", "dir", "elem", "clusters", "edgePaths", "edgeLabels", "nodes", "v", "node", "data", "ranksep", "nodesep", "o", "newEl", "updateNodeBounds", "setNodeElem", "findNonClusterChild", "clusterDb", "insertNode", "e", "edge", "insertEdgeLabel", "layout", "diff", "subGraphTitleTotalMargin", "getSubGraphTitleMargins", "sortNodesByHierarchy", "positionNode", "insertCluster", "point", "paths", "insertEdge", "positionEdgeLabel", "n", "render", "markers", "markers_default", "clear", "adjustClustersAndEdges", "getConfig", "sanitizeText", "__name", "txt", "common_default", "getConfig", "conf", "addNamespaces", "namespaces", "g", "_id", "diagObj", "log", "vertex", "node", "addClasses", "classes", "parent", "cssClassStr", "styles", "getStylesFromArray", "vertexText", "radius", "addNotes", "notes", "startEdgeId", "note", "i", "cssNoteStr", "edgeId", "edgeData", "interpolateToCurve", "linear_default", "addRelations", "relations", "cnt", "edge", "getEdgeId", "getArrowMarker", "setConf", "cnf", "draw", "text", "id", "_version", "securityLevel", "nodeSpacing", "rankSpacing", "Graph", "sandboxElement", "select_default", "root", "svg", "element", "render", "utils_default", "setupGraphViewbox", "doc", "labels", "label", "dim", "rect", "type", "marker", "classRenderer_v2_default", "diagram", "classDiagram_default", "classDb_default", "classRenderer_v2_default", "styles_default", "__name", "cnf"]
}
